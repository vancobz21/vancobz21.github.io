<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <title data-lang-key="title">Crayne Influence Counter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ===== CSS CUSTOM PROPERTIES ===== */
        :root {
            --menu-fade-opacity: 0.6;
            --ready-transparency: 0.7;
            --scale-enlarge: 1.3;
            --scale-hover: 1.05;
            --scale-ready-hover: 1.1;
            --ready-font-size: 5.04em;
            --ready-btn-size: 5.6em;
            --card-padding: 0.5rem;
            --layout-6b-padding: 0.25rem;
            --menu-margin: 0.75rem;
            --version-bottom: 0.35rem;
            --defeated-opacity: 0.4;
            --transition-timing: 0.3s ease-in-out;
            --border-radius-full: 9999px;
        }
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            /* ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ viewport ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞ */
            height: 100vh; /* fallback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö browser ‡πÄ‡∏Å‡πà‡∏≤ */
            height: 100dvh;
            max-height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô bounce effect ‡πÉ‡∏ô iOS Safari */
            -webkit-overflow-scrolling: touch;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ zoom ‡πÅ‡∏•‡∏∞ bounce scroll */
            -webkit-text-size-adjust: 100%;
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô rubber banding effect ‡πÉ‡∏ô iOS */
            overscroll-behavior: none;
            -webkit-overscroll-behavior: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        .defeated-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(40, 10, 10, 0.6);
            color: #6e2424;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            padding: 1rem;
            text-align: center;
            z-index: 36;
        }
        .setup-image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            max-width: 80%;
            height: auto;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin-left: auto;
            margin-right: auto;
        }
        .setup-image { width: 100%; height: auto; display: block; }
        /* Menu Container - Default center-screen positioning */
        #menu-container { 
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            transition: all 0.3s ease-in-out;
            cursor: move;
            user-select: none;
        }
        
        #menu-container.dragging {
            transition: none !important;
        }
        
        /* Fade state when inactive */
        #menu-container.faded { opacity: var(--menu-fade-opacity); }

        /* Alternative positioning classes for specific layouts - removed bottom-center as menu stays center-screen */

        #menu-btn {
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: var(--border-radius-full);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background-color 0.2s;
        }
        #menu-btn .badge {
            position: absolute;
            top: -0.4rem;
            right: -0.4rem;
            width: 1.4rem;
            height: 1.4rem;
            border-radius: 9999px;
            background: #111827; /* gray-900 */
            color: #fff;
            font-size: 0.65rem;
            font-weight: 700;
            line-height: 1.4rem;
            text-align: center;
            border: 2px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            pointer-events: none; /* non-interactive */
            user-select: none;
        }
        #menu-btn:hover { 
            transform: scale(var(--scale-hover)); 
            background-color: rgba(255, 255, 255, 0.7);
        }

        
        /* Dropdown positioning based on menu position */
        #menu-container.position-right #menu-dropdown {
            left: 100%;
            right: auto;
            bottom: 50%;
            top: auto;
            transform: translateY(50%);
            margin-left: 0.75rem;
            margin-right: 0;
            transform-origin: left center;
            width: 260px;
        }
        
        #menu-container.position-bottom #menu-dropdown {
            top: 100%;
            bottom: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            margin-top: 0.75rem;
            margin-left: 0;
            margin-right: 0;
            transform-origin: center top;
        }
        
        #menu-container.position-top #menu-dropdown {
            bottom: 100%;
            top: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            margin-bottom: 0.75rem;
            margin-left: 0;
            margin-right: 0;
            transform-origin: center bottom;
        }
        
        #menu-container.position-left #menu-dropdown {
            right: 100%;
            left: auto;
            bottom: 50%;
            top: auto;
            transform: translateY(50%);
            margin-right: 0.75rem;
            margin-left: 0;
            transform-origin: right center;
            width: 260px;
        }

        /* Default dropdown positioning for center-screen */
        #menu-dropdown {
            position: absolute; 
            top: 100%;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            width: 280px;
            margin-top: 0.75rem;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            opacity: 0;
            transform-origin: center top;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
        }

        /* Active dropdown states */
        #menu-dropdown.active { 
            opacity: 1; 
            pointer-events: auto; 
        }
        
        /* Default active state (center-screen) */
        #menu-dropdown.active { 
            transform: translateX(-50%) scale(1); 
        }
        
        /* Position-specific active states */
        #menu-container.position-right #menu-dropdown.active { 
            transform: translateY(50%) scale(1); 
        }
        
        #menu-container.position-left #menu-dropdown.active { 
            transform: translateY(50%) scale(1); 
        }
        

        
        #menu-dropdown button { width: 100%; text-align: left; padding: 0.75rem 1rem; transition: background-color 0.2s; }
        #menu-dropdown button:hover { background-color: rgba(0, 0, 0, 0.05); }
        
        /* Compact menu button styles */
        .menu-btn-compact {
            padding: 0.5rem 0.75rem !important;
            font-size: 0.875rem !important;
            text-align: center !important;
            border-radius: 0.375rem;
            margin: 0.125rem;
        }
        .menu-btn-compact:hover {
            background-color: rgba(0, 0, 0, 0.08) !important;
            transform: translateY(-1px);
        }
        
        /* Responsive menu adjustments */
        @media (max-width: 480px) {
            #menu-dropdown {
                width: 240px !important;
            }
            .menu-btn-compact {
                font-size: 0.8rem !important;
                padding: 0.4rem 0.6rem !important;
            }
        }
        
        @media (max-width: 320px) {
            #menu-dropdown {
                width: 200px !important;
            }
        }
        
        #turn-indicator-container {
            position: fixed;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 40;
            transition: all 0.3s ease-in-out;
        }
        #turn-indicator-container.top-center { 
            top: 1rem; 
            left: 50%;
            transform: translateX(-50%); 
        }

        #random-result-box {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            padding: 2rem 4rem;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 2rem;
            font-size: 8rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #random-result-box.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .first-player-highlight {
            color: #FFD700 !important;
            text-shadow: -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff, 0 0 15px #FFD700;
        }
        .life-display {
            font-size: clamp(3rem, 20vmin, 10rem);
        }
        .damage-display {
            font-weight: 900;
            color: #f87171;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
        }


        /* ATK/DEF Icon styles */
        .atk-icon-container, .def-icon-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 3.3em;
            height: 3.3em;
            margin: 0;
        }
        
        .atk-icon-container svg, .def-icon-container svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3));
        }
        
        .atk-icon-container .atk-display, .def-icon-container .def-display {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: 600;
            font-size: 1.8em;            
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
            z-index: 10;
        }
        @keyframes life-pop-fade {
            0% { transform: translate(-50%, 0) scale(0.9); opacity: 1; }
            66% { transform: translate(-50%, -20px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1.1); opacity: 0; }
        }
        .life-change-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: clamp(3rem, 8vmin, 3rem);
            font-weight: 700;
            pointer-events: none;
            z-index: 26;
            animation: life-pop-fade 2s ease-out forwards;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .content-wrapper {
            transition: transform 0.3s ease-in-out;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* Layout utilities - cleaned up, only essential styles */
        .layout-6b .player-card {
            min-height: 0 !important;
            overflow: hidden !important;
        }
        .layout-6b .content-wrapper {
            padding: var(--layout-6b-padding) var(--card-padding) !important;
            height: 100% !important;
            box-sizing: border-box !important;
        }
        /* Add subtle left/right breathing room inside every card */
        .content-wrapper {
            padding-left: var(--card-padding) !important;
            padding-right: var(--card-padding) !important;
        }
        
        /* Global block UI */
        .dual-block-ui, .single-block-ui {
            justify-content: space-between !important;
        }
        
        .ready-indicator.active {
            opacity: var(--ready-transparency) !important;
            filter: drop-shadow(0 0 7.5px #941e1e) drop-shadow(0 0 10px #941e1e) drop-shadow(0 0 22.5px #ef4444);
            font-size: var(--ready-font-size);
        }
        
        .ready-life-btn {
            cursor: pointer;
            border-radius: 50%;
            width: var(--ready-btn-size);
            height: var(--ready-btn-size);
        }

        /* Enlarge +/- buttons for atk/def/block by ~20% (exclude life controls) */
        button[data-action^="increment-"]:not([data-action$="-life"]),
        button[data-action^="decrement-"]:not([data-action$="-life"]) {
            transform: scale(var(--scale-enlarge));
            transform-origin: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* Special styling for rotation button */
        button[data-action="rotate"] {
            transform: scale(1.1);
            transform-origin: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(4px);
            transition: all 0.2s ease-in-out;
        }
        
        button[data-action="rotate"]:hover {
            transform: scale(1.2) rotate(15deg);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        button[data-action="rotate"]:active {
            transform: scale(1.0) rotate(90deg);
        }
        
        button[data-action="rotate"]:active .rotate-icon {
            animation: rotateIcon 0.3s ease-in-out;
        }
        

        
        /* CSS ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î - ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏´‡∏°‡∏∏‡∏ô */
        .content-wrapper {
            /* ‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà container ‡πÄ‡∏™‡∏°‡∏≠ */
            width: 100% !important;
            height: 100% !important;
            position: relative;
            overflow: hidden;
        }
        .rotator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
        }
        
        /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS/iPadOS - ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠ */
        .ios-friendly {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS */
            max-height: 100dvh;
            /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏î‡∏´‡∏î‡πÉ‡∏ô iOS */
            position: relative;
            overflow: hidden;
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ bounce scroll ‡πÅ‡∏•‡∏∞ zoom */
            -webkit-text-size-adjust: 100%;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            overscroll-behavior: none;
        }

        .iphone-mode {
            height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 40px) !important;
            max-height: calc(100vh - 80px) !important;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
        }
        
        .iphone-mode-container {
            padding-top: max(env(safe-area-inset-top), 0px) !important;
            padding-bottom: max(env(safe-area-inset-bottom), 30px) !important;
            padding-left: env(safe-area-inset-left) !important;
            padding-right: env(safe-area-inset-right) !important;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center ios-friendly">
    <div id="setup-controls" class="bg-white p-4 rounded-2xl shadow-xl w-full max-w-4xl mx-auto text-center m-auto">
        <div class="flex justify-end mb-2">
            <select id="language-selector" class="p-1 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200 text-sm">
                <option value="th">‡πÑ‡∏ó‡∏¢</option>
                <option value="en" selected>English</option>
            </select>

            <label class="flex items-center space-x-2 text-sm ml-4">
                <input type="checkbox" id="no-taunt-toggle" class="form-checkbox">
                <span data-lang-key="noTauntMode">No taunt</span>
            </label>
            <label class="flex items-center space-x-2 text-sm ml-4">
                <input type="checkbox" id="no-auto-ready-toggle" class="form-checkbox">
                <span data-lang-key="noAutoReadyMode">No auto ready</span>
            </label>
        </div>

        <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-2" data-lang-key="appTitle"></h1>
        <div class="setup-image-container">
            <img src="CrayneLogo.jpg" alt="Crayne Fractured Empire Logo" class="setup-image" onerror="this.onerror=null;this.src='https://placehold.co/600x300/e2e8f0/4a5568?text=Crayne+Logo';">
        </div>
        <div class="flex flex-col items-center justify-center">
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4">
                <div class="flex items-center space-x-2 w-full sm:w-auto">
                    <label for="player-count" class="text-md sm:text-lg font-semibold text-gray-700" data-lang-key="playerCountLabel"></label>
                    <select id="player-count" class="p-1 sm:p-2 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5B">5</option>
                        <option value="5C">5B</option>
                        <option value="6B">6</option>
                        <option value="6C">6B</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                    </select>
                </div>
                <button id="start-btn" class="w-full sm:w-auto py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="startButton"></button>
            </div>
            <div id="color-select-panel" class="mt-4 flex flex-wrap justify-center items-center gap-2"></div>
            <div class="mt-4 flex items-center justify-center space-x-4">
                <p id="version-display" class="text-xs text-gray-400 select-none">version i1.9.5-Rework Layout</p>
                <button id="instructions-link" class="text-xs text-blue-500 hover:text-blue-700 underline" data-lang-key="instructionsLink">‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ</button>
            </div>
        </div>
        
        <div class="absolute bottom-4 left-4 text-left">
            <a href="https://vancobz21.github.io/index3125.html" target="_blank" class="text-xs text-gray-400 hover:text-blue-500 transition-colors">
                Stable Version
            </a>
        </div>
    </div>
    
    <div id="players-container" class="w-full h-full flex-grow grid min-h-0"></div>

    <div id="next-turn-container" class="hidden fixed inset-0 flex items-center justify-center z-30 pointer-events-none">
        <div class="flex items-center space-x-4 pointer-events-auto">
            <button id="undo-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold p-3 rounded-full shadow-lg transition-transform active:scale-90">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"></path></svg>
            </button>
            <button id="next-turn-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg opacity-80" data-lang-key="next_turn_btn"></button>
        </div>
    </div>

    <div id="menu-container" class="hidden">
        <div class="relative">
            <button id="menu-btn" class="text-gray-600 relative">
                <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                <span id="menu-turn-badge" class="badge">1</span>
            </button>
            <div id="menu-dropdown" class="text-gray-800 grid grid-cols-2 gap-1">
                <button id="restart-game-btn" data-lang-key="menuRestart" class="menu-btn-compact"></button>
                <button id="toggle-fullscreen-btn" data-lang-key="menuFullscreen" class="menu-btn-compact"></button>
                <button id="toggle-countdown-btn" data-lang-key="toggleCountdown" class="menu-btn-compact">‚è±Ô∏èAuto</button>
                <button id="open-log-btn" data-lang-key="menuLog" class="menu-btn-compact"></button>
                <button id="random-btn" data-lang-key="menuRandom" class="menu-btn-compact"></button>
                <button id="menu-instructions-btn" data-lang-key="menuInstructions" class="menu-btn-compact"></button>
            </div>
        </div>
    </div>

    <div id="turn-indicator-container" class="hidden">
         <button id="turn-log-indicator" class="bg-gray-800 text-white text-xs font-bold w-8 h-8 rounded-full flex items-center justify-center border-2 border-white shadow-md">
            1
        </button>
    </div>

    <div id="random-result-box" class="hidden"></div>
    
        <!-- Simple Game Over Modal -->
        <div id="simple-gameover-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50">
            <div id="simple-gameover-modal-box" class="bg-white p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full">
                <p id="simple-gameover-message" class="text-3xl font-extrabold mb-10 leading-tight"></p>
                <button id="simple-gameover-close" class="py-4 px-10 text-xl bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-2xl transition-colors" data-lang-key="newGameButton">New Game</button>
            </div>
        </div>

    <div id="log-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-lg h-3/4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800" data-lang-key="logTitle">Game Log</h2>
                <button id="close-log-btn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="log-content" class="flex-grow overflow-y-auto bg-gray-100 p-4 rounded-lg"></div>
        </div>
    </div>

    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full">
            <h2 id="confirm-modal-title" class="text-2xl font-bold text-gray-800 mb-4">Are you sure?</h2>
            <p id="confirm-modal-text" class="text-gray-600 mb-6">This action cannot be undone.</p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-cancel-btn" class="py-2 px-6 bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold rounded-xl transition-colors">Cancel</button>
                <button id="confirm-ok-btn" class="py-2 px-6 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-xl transition-colors">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-4xl h-5/6 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800" data-lang-key="instructionsTitle">How to Use CIC</h2>
                <button id="close-instructions-btn" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
            </div>
            <div id="instructions-content" class="flex-grow overflow-y-auto bg-gray-50 p-4 rounded-lg text-sm leading-relaxed">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIG =====
        const CONFIG = {
            STARTING_LIFE: { 2: 30, default: 60 },
            DELAYS: { SYNC_TIMEOUT: 100, ORIENTATION_CHANGE: 250, RESIZE_DEBOUNCE: 300, DRAG_THRESHOLD: 10, HASMOVED_RESET: 100, AUTO_READY: 15000 },
            UI: { MENU_FADE_TIMEOUT: 3000 }
        };
        
        const CUSTOM_ORDERS = { 2: [1, 2], 3: [1, 2, 3], 4: [1, 2, 4, 3], 7: [1, 2, 3, 4, 6, 7, 5], 8: [1, 2, 4, 6, 8, 7, 5, 3] };
        
        const B_MODE_TURN_ORDERS = {
            '6B': [1, 3, 5, 6, 4, 2],
            '6C': [1, 2, 4, 6, 5, 3],
            '5B': [3, 5, 6, 4, 2],
            '5C': [3, 5, 6, 4, 2]
        };
        const COLOR_FAMILIES = [ [ { name: '‡πÅ‡∏î‡∏á', name_en: 'Red', tailwindClass: 'bg-red-600', textColorClass: 'text-red-600' }, { name: '‡∏Å‡∏∏‡∏´‡∏•‡∏≤‡∏ö', name_en: 'Rose', tailwindClass: 'bg-rose-500', textColorClass: 'text-rose-500' }, { name: '‡∏ä‡∏°‡∏û‡∏π', name_en: 'Pink', tailwindClass: 'bg-pink-500', textColorClass: 'text-pink-500' }, ], [ { name: '‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô', name_en: 'Blue', tailwindClass: 'bg-blue-600', textColorClass: 'text-blue-600' }, { name: '‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤', name_en: 'Sky', tailwindClass: 'bg-sky-500', textColorClass: 'text-sky-500' }, { name: '‡∏Ñ‡∏£‡∏≤‡∏°', name_en: 'Indigo', tailwindClass: 'bg-indigo-500', textColorClass: 'text-indigo-500' }, ], [ { name: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß', name_en: 'Green', tailwindClass: 'bg-green-600', textColorClass: 'text-green-600' }, { name: '‡∏°‡∏£‡∏Å‡∏ï', name_en: 'Emerald', tailwindClass: 'bg-emerald-500', textColorClass: 'text-emerald-500' }, { name: '‡∏ü‡πâ‡∏≤‡∏≠‡∏°‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß', name_en: 'Teal', tailwindClass: 'bg-teal-500', textColorClass: 'text-teal-500' }, { name: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏°‡∏∞‡∏ô‡∏≤‡∏ß', name_en: 'Lime', tailwindClass: 'bg-lime-500', textColorClass: 'text-lime-500' }, ], [ { name: '‡∏°‡πà‡∏ß‡∏á', name_en: 'Purple', tailwindClass: 'bg-purple-600', textColorClass: 'text-purple-600' }, { name: '‡πÑ‡∏ß‡πÇ‡∏≠‡πÄ‡∏•‡πá‡∏ï', name_en: 'Violet', tailwindClass: 'bg-violet-600', textColorClass: 'text-violet-600' }, ], [ { name: '‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á', name_en: 'Yellow', tailwindClass: 'bg-yellow-400', textColorClass: 'text-yellow-400' }, { name: '‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á‡∏≠‡∏≥‡∏û‡∏±‡∏ô', name_en: 'Amber', tailwindClass: 'bg-amber-500', textColorClass: 'text-amber-500' }, { name: '‡∏™‡πâ‡∏°', name_en: 'Orange', tailwindClass: 'bg-orange-500', textColorClass: 'text-orange-500' }, ], [ { name: '‡πÄ‡∏ó‡∏≤', name_en: 'Slate', tailwindClass: 'bg-slate-500', textColorClass: 'text-slate-500' },  ] ];
        const DEFEAT_TAUNTS = { th: [ "‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏à‡∏∏‡∏î‡∏≠‡πà‡∏≠‡∏ô!", "‡∏Å‡πä‡∏≤‡∏≤‡∏≤‡∏≤‡∏Å ‡∏Å ‡∏≤ ‡∏Å", "‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏Å‡∏∏‡∏®‡∏•", "‡∏™‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡πâ‡∏≤ 555", "‡πÅ‡∏Ñ‡πà‡∏ô‡∏µ‡πâ‡∏Å‡πá‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏î ‡∏™‡∏±‡∏™", "‡πÑ‡∏õ‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πä", "‡πÑ‡∏´‡∏ß‡∏õ‡πà‡∏∞‡πÄ‡∏ô‡∏µ‡πà‡∏¢?", "‡∏á‡πà‡∏ß‡∏á‡∏´‡∏£‡∏≤‡∏≤", "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏≠‡∏µ‡∏Å‡∏™‡∏±‡∏Å‡∏£‡πâ‡∏≠‡∏¢‡∏°‡∏∞?", "‡∏°‡∏±‡∏ô‡∏à‡πâ‡∏≤‡∏ã‡∏∞‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏ô!!", "‡πÑ‡∏≠‡πâ‡∏™‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡∏û‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÄ‡∏ñ‡∏≠‡∏∞", "‡∏ô‡∏¥‡πà‡∏°‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ ‡∏Ñ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏µ‡πâ‡∏ß‡∏∞!", "‡πÑ‡∏õ‡∏´‡∏ß‡∏±‡∏ô‡∏ã‡∏∞‡∏•‡∏∞", "‡∏£‡∏µ‡∏ö‡πÑ‡∏õ‡πÑ‡∏´‡∏ô ‡πÅ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡∏ã‡∏∑‡πâ‡∏≠‡∏ô‡πâ‡∏≥‡∏õ‡∏•‡∏≤‡πÄ‡∏´‡∏£‡∏≠", "‡∏≠‡∏∞‡πÄ‡∏´‡∏∑‡πâ‡∏≠!! ‡∏ù‡∏≤‡∏Å‡∏•‡∏π‡∏Å‡πÄ‡∏°‡∏µ‡∏¢‡∏Ç‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢", "‡πÑ‡∏ß‡πâ‡πÄ‡∏à‡∏≠‡∏Å‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏£‡πâ‡∏≤‡∏≤", "‡πÄ‡∏ò‡∏≠‡∏Ñ‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏´‡∏ô‡∏∂‡πà‡∏á...‡∏à‡∏≤‡∏Å‡∏ó‡πâ‡∏≤‡∏¢", "‡∏ô‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏≠‡∏≤‡∏Æ‡∏≤‡πÉ‡∏ä‡πà‡∏õ‡∏∞?", "R I P", "‡πÑ‡∏õ‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤ ‡∏î‡∏≥‡∏ô‡πâ‡∏≥ ‡∏î‡∏π‡∏õ‡∏∞‡∏Å‡∏≤‡∏£‡∏±‡∏á ‡∏Ø‡∏Ø", "‡πÑ‡∏õ‡∏ô‡∏±‡πà‡∏á‡∏™‡∏°‡∏≤‡∏ò‡∏¥‡∏£‡∏≠‡∏ô‡∏∞", "‡πÄ‡∏Å‡∏°‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô‡∏≠‡πà‡∏≠‡∏ô‡πÅ‡∏≠", "‡∏Ç‡∏≠‡∏ô‡πâ‡∏≥‡πÉ‡∏ö‡∏ö‡∏±‡∏ß‡∏ö‡∏Å‡∏´‡∏ô‡πà‡∏≠‡∏¢", "‡∏¢‡∏∑‡∏ô‡πÄ‡∏â‡∏¢‡πÜ ‡πÄ‡∏Ç‡∏≤‡∏Å‡πá‡∏ä‡∏ô‡∏∞", "‡∏Ñ‡πà‡∏≤‡∏à‡πâ‡∏≤‡∏á‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà‡πÄ‡∏ô‡∏µ‡πà‡∏¢?", "‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û", "‡∏ö‡∏ó‡∏ô‡πâ‡∏≠‡∏¢‡∏à‡∏±‡∏á‡∏ß‡∏∞", "‡∏ï‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏á‡∏ö ‡∏®‡∏û‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π", "‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡∏ï‡∏≤‡∏°‡∏ó‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á", "‡πÄ‡∏Å‡∏°‡∏û‡∏•‡∏¥‡∏Å‡∏ß‡πà‡∏∞...‡∏û‡∏•‡∏¥‡∏Å‡∏•‡∏á‡∏´‡∏•‡∏∏‡∏°" ], en: [ "Just a flesh wound.", "I've seen better plays in my soup.", "Were you trying?", "That was... an attempt.", "Error 404: Skill not found.", "Next time, try plugging in the controller.", "My grandma plays better.", "You're the reason for participation trophies.", "At least you tried. Or did you?", "I'm not mad, just disappointed.", "Task failed successfully.", "It's okay, we all have off-days.", "Maybe this isn't your game.", "A for effort, F for result.", "Did you lag?", "I'll send you a tutorial link.", "That's rough, buddy.", "You have been unsubscribed from life.", "GG EZ.", "Better luck next millennium." ] };
    const TRANSLATIONS = { 'th': { title: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏±‡∏ö Influence Crayne', appTitle: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏±‡∏ö Influence Crayne', playerCountLabel: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô:', startButton: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°', gameOverTitle: '‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß!', newGameButton: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà', ready: '‡∏û‡∏£‡πâ‡∏≠‡∏°', defeated: '‡πÅ‡∏û‡πâ‡πÅ‡∏•‡πâ‡∏ß',  winnerMsg: (c) => `‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ${c} ‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞!`, noWinnerMsg: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞!', menuRestart: 'üîÑ ‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó', menuFullscreen: '‚õ∂ ‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠', menuExitFullscreen: '‚õå ‡∏¢‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠', menuRandom: 'üé≤ ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç', menuLog: 'üìã Log', menuInstructions: '‚ùì ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ', next_turn_btn: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ', logTitle: 'Log ‡πÄ‡∏Å‡∏°', logTurn: (t) => `‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà ${t}`, instructionsTitle: '‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô CIC', instructionsLink: '‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ', noTauntMode: '‡πÑ‡∏°‡πà‡πÅ‡∏≠‡∏ö‡πÅ‡∏ã‡∏ß', defeatedNoTaunt: '‡∏û‡πà‡∏≤‡∏¢‡πÅ‡∏û‡πâ', noAutoReadyMode: '‡πÑ‡∏°‡πà Auto Ready', toggleCountdown: '‚è±Ô∏è Auto', restore_title: '‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Å‡∏°‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô?', restore_subtitle: '‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ', players: '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô', turn: '‡∏£‡∏≠‡∏ö', layout: '‡πÄ‡∏•‡∏¢‡πå‡πÄ‡∏≠‡∏≤‡∏ó‡πå', saved: '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å', cancel: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å', restore: '‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Å‡∏°', game_restored: '‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' }, 'en': { title: 'Crayne Influence Counter', appTitle: 'Crayne Influence Counter', playerCountLabel: 'Players:', startButton: 'Start Game', gameOverTitle: 'Game Over!', newGameButton: 'New Game', ready: 'Ready', defeated: 'Defeated',  winnerMsg: (c) => `Player ${c} wins!`, noWinnerMsg: 'No Winner!', menuRestart: 'üîÑ Restart', menuFullscreen: '‚õ∂ Fullscreen', menuExitFullscreen: '‚õå Exit Full', menuRandom: 'üé≤ Random', menuLog: 'üìã Log', menuInstructions: '‚ùì Guide', next_turn_btn: 'Next Turn', logTitle: 'Game Log', logTurn: (t) => `Turn ${t}`, instructionsTitle: 'How to Use CIC', instructionsLink: 'Instructions', noTauntMode: 'No taunt', defeatedNoTaunt: 'Defeated', noAutoReadyMode: 'No auto ready', toggleCountdown: '‚è±Ô∏è Auto', restore_title: 'Restore Previous Game?', restore_subtitle: 'Found saved game data', players: 'Players', turn: 'Turn', layout: 'Layout', saved: 'Saved', cancel: 'Cancel', restore: 'Restore Game', game_restored: 'Game restored successfully!' } };

        
        const INSTRUCTIONS_CONTENT = {
            'th': `
                <div class="space-y-4">
                    <div class="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400">
                        <h3 class="font-bold text-lg mb-2">‡πÅ‡∏ö‡∏ö‡∏™‡∏±‡πâ‡∏ô TL:DR version</h3>
                        <ol class="list-decimal list-inside space-y-1 text-sm">
                            <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Layout ‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</li>
                            <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</li>
                            <li>‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç‡∏ó‡∏≠‡∏á‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏≠‡∏ö</li>
                            <li>‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö 5 ‡πÉ‡∏ö ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏≠‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ATK/DEF/Stronghold/Influence ‡∏Å‡∏£‡∏≠‡∏Å‡∏•‡∏á‡πÉ‡∏ô‡πÅ‡∏≠‡∏õ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö</li>
                            <li>‡∏Å‡∏î ready ‡πÇ‡∏î‡∏¢‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç Influence (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏™‡∏∏‡∏î) ‡∏à‡∏∞‡∏°‡∏µ icon ‡∏î‡∏≤‡∏ö‡πÑ‡∏Ç‡∏ß‡πâ‡πÅ‡∏™‡∏î‡∏á ‡πÅ‡∏•‡∏∞‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</li>
                            <li>‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏î‡∏≤‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏à‡∏∞‡∏õ‡∏•‡∏î ready ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ</li>
                            <li>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏Ñ‡∏£‡∏ö‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì damage ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö Influence ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</li>
                            <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏∏‡πà‡∏° << (undo) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏´‡∏£‡∏∑‡∏≠ Next Turn ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà‡∏´‡∏≤‡∏Å‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß</li>
                            <li>‡∏ó‡∏≥‡∏Ç‡πâ‡∏≠ 3 ‡∏ß‡∏ô‡πÑ‡∏õ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡∏Ñ‡∏ô‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏î‡∏î‡∏¥‡πâ‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏°‡∏î</li>
                        </ol>
                    </div>
                    
                    <div>
                        <h3 class="font-bold text-lg mb-3">Pre-game</h3>
                        <ol class="list-decimal list-inside space-y-2">
                            <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</li>
                            <li>‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</li>
                            <li>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∞‡∏ô‡∏≥‡∏°‡∏≤‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô</li>
                            <li>‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç Influence ‡∏™‡∏µ‡∏ó‡∏≠‡∏á‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏≠‡∏ö</li>
                            <li>‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î: ‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÅ‡∏£‡∏Å‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏°‡∏∏‡∏ô (‚Üª) ‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î 90 ‡∏≠‡∏á‡∏®‡∏≤ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏°‡∏∏‡∏ô‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£</li>
                            <li>‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏≤‡∏°‡∏Ç‡∏µ‡∏î‡∏°‡∏µ Badge ‡∏ö‡∏≠‡∏Å‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠‡πÄ‡∏Å‡∏° ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏≤‡∏Å‡∏ß‡∏≤‡∏á‡πÉ‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ ‡πÉ‡∏ô‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏≤‡∏°‡∏Ç‡∏µ‡∏î‡∏à‡∏∞‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó : ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏£‡∏Å</li>
                                    <li>‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠ : ‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏•‡∏∞‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</li>
                                    <li>Log ‡πÄ‡∏Å‡∏° : ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≠‡∏ö</li>
                                    <li>‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç : ‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏ó‡πà‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ï‡∏•‡∏≤‡∏î ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡∏™‡∏∏‡πà‡∏° Sacrifice ‡∏ï‡∏•‡∏≤‡∏î</li>
                                </ul>
                            </li>
                            <li><strong>‡∏£‡∏∞‡∏ö‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥:</strong> ‡πÄ‡∏Å‡∏°‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏´‡∏≤‡∏Å‡πÅ‡∏≠‡∏õ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡∏õ‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏à ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Å‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏•‡∏±‡∏á 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á)</li>
                        </ol>
                    </div>
                    
                    <div>
                        <h3 class="font-bold text-lg mb-3">Gameplay</h3>
                        <ol class="list-decimal list-inside space-y-2">
                            <li>‡πÄ‡∏•‡πà‡∏ô Assembly Phase ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö 5 ‡πÉ‡∏ö)</li>
                            <li>‡∏ô‡∏±‡∏ö‡∏£‡∏ß‡∏°‡∏Ñ‡πà‡∏≤ ATK/ DEF/Stronghold ‡∏ã‡πâ‡∏≤‡∏¢ /Stronghold ‡∏Ç‡∏ß‡∏≤ ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</li>
                            <li>‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏° (+)/(-) ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô ‡πÇ‡∏î‡∏¢
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>Stronghold ‡∏ã‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏Ç‡∏ß‡∏≤‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á Stronghold ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</li>
                                    <li>ATK ‡πÅ‡∏•‡∏∞ DEF ‡∏à‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏•‡πà‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢ ‡πÅ‡∏•‡∏∞ ‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö</li>
                                    <li>‡πÄ‡∏•‡∏Ç‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï ‡∏´‡∏£‡∏∑‡∏≠ Influence ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏° (+)/(-) ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç</li>
                                </ul>
                            </li>
                            <li>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° ‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏î‡∏≤‡∏ö‡πÑ‡∏Ç‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° ‡πÅ‡∏•‡∏∞‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏° (‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö influence ‡πÑ‡∏î‡πâ)</li>
                            <li>‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏Å‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏≠‡∏õ‡∏õ‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏Å‡∏•‡∏ö Influence ‡πÉ‡∏´‡πâ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</li>
                            <li>‡∏à‡∏∞‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏° (<<) ‡πÅ‡∏•‡∏∞‡∏õ‡∏∏‡πà‡∏° Next turn ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡∏•‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>‡∏õ‡∏∏‡πà‡∏° Next turn : ‡∏Å‡∏î ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏à‡∏ö Revenue Phase (‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ</li>
                                    <li>‡∏õ‡∏∏‡πà‡∏° (<<) : undo ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‡∏î‡∏≤‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡πå‡∏î)</li>
                                </ul>
                            </li>
                            <li>‡∏ß‡∏ô‡∏ã‡πâ‡∏≥‡∏Ç‡πâ‡∏≠ (1)-(6) ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏à‡∏ö‡πÄ‡∏Å‡∏°</li>
                        </ol>
                    </div>
                    
                    <div class="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-400">
                        <h3 class="font-bold text-lg mb-2">‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°</h3>
                        <ul class="list-disc list-inside space-y-1">
                            <li>‡∏°‡∏µ‡∏ö‡∏±‡πä‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ö‡∏≤‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ç‡∏¢‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÅ‡∏•‡πâ‡∏ß‡∏•‡πâ‡∏ô ‡πÅ‡∏Å‡πâ‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏≠‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏û‡∏≠‡∏î‡∏µ‡∏à‡∏≠</li>
                            <li>‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ iPhone ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πâ‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô‡∏ä‡∏≤‡∏ß‡∏ö‡πâ‡∏≤‡∏ô‡∏ä‡∏≤‡∏ß‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡πÄ‡∏Ç‡∏≤</li>
                            <li>‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏≤‡∏°‡∏Ç‡∏µ‡∏î (‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÄ‡∏Å‡∏≠‡∏£‡πå‡πÄ‡∏°‡∏ô‡∏π) ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏≤‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ!</li>
                            <li>‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î: ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏∞‡∏õ‡∏£‡∏≤‡∏Å‡∏è‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÅ‡∏£‡∏Å‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡∏´‡∏≤‡∏¢‡πÑ‡∏õ ‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏à‡∏≤‡∏Å‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°</li>
                            <li><strong>‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå Apple (iPad/iPhone):</strong>
                                <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
                                    <li>‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏≠‡∏õ‡πÉ‡∏ô Safari</li>
                                    <li>‡∏Å‡∏î ‡∏õ‡∏∏‡πà‡∏° Share (‡∏™‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°‡∏°‡∏µ‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ä‡∏µ‡πâ‡∏Ç‡∏∂‡πâ‡∏ô) ‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ö‡∏•‡πà‡∏≤‡∏á</li>
                                    <li>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "Add to Home Screen" ‡∏´‡∏£‡∏∑‡∏≠ "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏´‡∏•‡∏±‡∏Å"</li>
                                    <li>‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏≠‡∏õ (‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏°) ‡πÅ‡∏•‡∏∞‡∏Å‡∏î "Add"</li>
                                    <li>‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏≠‡∏õ‡∏à‡∏≤‡∏Å Home Screen ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Safari</li>
                                    <li>‡πÑ‡∏î‡πâ‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö Web App ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏° Safari ‡∏°‡∏≤‡∏ö‡∏±‡∏á ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</li>
                                </ol>
                            </li>
                        </ul>
                        <p class="mt-3 text-sm">‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ï‡∏¥‡∏ä‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà : <a href="mailto:vancobz21@gmail.com" class="text-blue-600 hover:text-blue-800">vancobz21@gmail.com</a></p>
                    </div>
                </div>
            `,
            'en': `
                <div class="space-y-4">
                    <div class="bg-blue-50 p-4 rounded-lg border-l-4 border-blue-400">
                        <h3 class="font-bold text-lg mb-2">Quick Start (TL:DR)</h3>
                        <ol class="list-decimal list-inside space-y-1 text-sm">
                            <li>Choose layout based on number of players</li>
                            <li>Select colors for random seating after starting game</li>
                            <li>Player with gold numbers is the first player of the round</li>
                            <li>Play 5 cards and input ATK/DEF/Stronghold/Influence data into the app</li>
                            <li>Click ready by clicking the Influence number (largest number) - sword icon will appear and lock data entry</li>
                            <li>Click sword icon again to cancel ready and allow more data input</li>
                            <li>When all players are ready, damage is calculated and Influence is adjusted automatically</li>
                            <li>Choose << (undo) button to go back and edit data, or Next Turn to start new round after buying</li>
                            <li>Repeat step 3 until there's one winner or everyone is eliminated</li>
                        </ol>
                    </div>
                    
                    <div>
                        <h3 class="font-bold text-lg mb-3">Pre-game</h3>
                        <ol class="list-decimal list-inside space-y-2">
                            <li>Select number of players</li>
                            <li>All players choose colors and click Start Game</li>
                            <li>When game starts, selected colors are randomly assigned to seating positions</li>
                            <li>Player with gold Influence number is the first player of the round</li>
                            <li>Card Rotation: Only in the first turn, players can click the rotation button (‚Üª) at the top of their card to rotate it 90 degrees. Can rotate multiple times until desired position is achieved</li>
                            <li>Burger menu with round badge appears in center screen, can be dragged anywhere. Menu contains:
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>Restart: Start new game, return to main screen</li>
                                    <li>Fullscreen: Enter/exit fullscreen mode</li>
                                    <li>Game Log: Information from each game round</li>
                                    <li>Random Number: Generate random numbers equal to market cards for Sacrifice effects</li>
                                </ul>
                            </li>
                            <li><strong>Automatic Game Save:</strong> The game automatically saves your progress. If the app crashes or closes accidentally, it will ask if you want to restore your game when reopened (data expires after 24 hours)</li>
                        </ol>
                    </div>
                    
                    <div>
                        <h3 class="font-bold text-lg mb-3">Gameplay</h3>
                        <ol class="list-decimal list-inside space-y-2">
                            <li>Play Assembly Phase normally (play 5 cards from hand)</li>
                            <li>Count total ATK/DEF/Left Stronghold/Right Stronghold from all played cards</li>
                            <li>Input data using (+)/(-) buttons completely:
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>Left and Right Strongholds shown as player colors you want to defend against at top corners</li>
                                    <li>ATK and DEF are at bottom-left and bottom-right corners respectively</li>
                                    <li>Life/Influence is the largest number in center of player card, adjustable anytime with (+)/(-) buttons on sides</li>
                                </ul>
                            </li>
                            <li>When data is complete, player clicks the number to show readiness. Player card shows crossed swords icon as ready signal and locks further data entry (but can still adjust influence)</li>
                            <li>When all players are ready, app automatically calculates damage and deducts Influence</li>
                            <li>Buttons (<<) and Next Turn appear in center screen:
                                <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                                    <li>Next Turn button: Click when all players finish Revenue Phase (market buying) to start next round</li>
                                    <li>(<<) button: Undo or go back to edit data (players must click sword to unlock cards)</li>
                                </ul>
                            </li>
                            <li>Repeat steps (1)-(6) until game ends</li>
                        </ol>
                    </div>
                    
                    <div class="bg-yellow-50 p-4 rounded-lg border-l-4 border-yellow-400">
                        <h3 class="font-bold text-lg mb-2">Additional Tips</h3>
                        <ul class="list-disc list-inside space-y-1">
                            <li>There's an unfixable bug where fullscreen sometimes overflows - fix by toggling fullscreen multiple times until it fits</li>
                            <li>iPhone users may have issues as the system doesn't support fullscreen mode</li>
                            <li>The burger menu can be dragged and moved around!</li>
                            <li>Card Rotation: The rotation button only appears in the first turn, then disappears. Make use of this feature to position your card optimally</li>
                            <li><strong>How to use on Apple devices (iPad/iPhone):</strong>
                                <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
                                    <li>Open the app in Safari</li>
                                    <li>Tap the Share button (square with upward arrow) in the bottom toolbar</li>
                                    <li>Select "Add to Home Screen"</li>
                                    <li>Name the app (or keep default name) and tap "Add"</li>
                                    <li>Launch the app from Home Screen instead of Safari</li>
                                    <li>Enjoy optimal Web App experience without Safari browser controls and full-screen usage</li>
                                </ol>
                            </li>
                        </ul>
                        <p class="mt-3 text-sm">Send feedback or suggestions to: <a href="mailto:vancobz21@gmail.com" class="text-blue-600 hover:text-blue-800">vancobz21@gmail.com</a></p>
                    </div>
                </div>
            `
        };
        
        // ===== UTILS =====
        const safe = (fn, fb = () => {}) => { try { return fn(); } catch(e) { return fb(); } };
        const validatePlayer = (id, action) => {
            const p = gameState.players.find(p => p.id === id);
            return p && (!p.isDefeated || action.includes('life'));
        };
        const $ = s => document.querySelector(s);
        const safeTimeout = (fn, delay) => setTimeout(() => safe(fn), delay);
        
        const gameState = {
            players: [], initialPlayerCount: 2, layoutMode: null, firstPlayerId: null, currentLang: 'en',
            isBuyPhase: false, turnCount: 0, gameLog: [], previousPlayerState: null, wakeLockSentinel: null,
            selectedColors: [], selectedFamilies: [], isGameOver: false, isDragging: false, 
            dragOffset: { x: 0, y: 0 }, hasMoved: false, startX: 0, startY: 0,
            menuFadeTimer: null, menuFaded: false, activeTimeouts: new Set(), autoReadyTimers: new Map(),
            saveTimeout: null, countdownEnabled: true
        };

        // ===== GAME STATE PERSISTENCE FUNCTIONS =====
        const saveGameState = () => {
            try {
                if (gameState.players.length === 0 || gameState.isGameOver) {
                    // Don't save if no active game
                    localStorage.removeItem('crayne_game_state');
                    return;
                }
                
                const gameData = {
                    players: gameState.players.map(p => ({
                        id: p.id,
                        life: p.life,
                        atk: p.atk,
                        def: p.def,
                        block: p.block,
                        leftBlock: p.leftBlock,
                        rightBlock: p.rightBlock,
                        isReady: p.isReady,
                        isDefeated: p.isDefeated,
                        isInitiallyDefeated: p.isInitiallyDefeated,
                        tailwindClass: p.tailwindClass,
                        textColorClass: p.textColorClass,
                        name: p.name,
                        name_en: p.name_en,
                        lastDamageTaken: p.lastDamageTaken,
                        manualRotation: p.manualRotation,
                        defeatTaunt: p.defeatTaunt
                    })),
                    initialPlayerCount: gameState.initialPlayerCount,
                    layoutMode: gameState.layoutMode,
                    firstPlayerId: gameState.firstPlayerId,
                    currentLang: gameState.currentLang,
                    isBuyPhase: gameState.isBuyPhase,
                    turnCount: gameState.turnCount,
                    gameLog: gameState.gameLog,
                    selectedColors: gameState.selectedColors,
                    countdownEnabled: gameState.countdownEnabled,
                    timestamp: Date.now(),
                    version: '1.8.0'
                };
                
                localStorage.setItem('crayne_game_state', JSON.stringify(gameData));
            } catch (error) {
                console.error('Failed to save game state:', error);
            }
        };

        const loadGameState = () => {
            try {
                const saved = localStorage.getItem('crayne_game_state');
                if (!saved) return null;
                
                const gameData = JSON.parse(saved);
                
                // Check if saved data is too old (older than 24 hours)
                if (gameData.timestamp && (Date.now() - gameData.timestamp) > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem('crayne_game_state');
                    return null;
                }
                
                return gameData;
            } catch (error) {
                console.error('Failed to load game state:', error);
                localStorage.removeItem('crayne_game_state');
                return null;
            }
        };

        const restoreGameState = (gameData) => {
            try {
                // Store restored data temporarily
                const restoredPlayers = gameData.players || [];
                const restoredGameLog = gameData.gameLog || [];
                const restoredTurnCount = gameData.turnCount || 0;
                const restoredIsBuyPhase = gameData.isBuyPhase || false;
                const restoredFirstPlayerId = gameData.firstPlayerId;
                
                // Set basic game state for initPlayers to work properly
                gameState.initialPlayerCount = gameData.initialPlayerCount || 2;
                gameState.layoutMode = gameData.layoutMode;
                gameState.currentLang = gameData.currentLang || 'en';
                gameState.selectedColors = gameData.selectedColors || [];
                gameState.countdownEnabled = gameData.countdownEnabled !== undefined ? gameData.countdownEnabled : true;
                
                // Restore UI to game state
                ui.setupControls.classList.add('hidden');
                ui.playersContainer.style.display = 'grid';
                
                // Set language
                ui.languageSelector.value = gameState.currentLang;
                setLanguage(gameState.currentLang);
                
                // Use normal initPlayers for proper layout and structure
                ui.playersContainer.innerHTML = '';
                initPlayers();
                
                // Now restore the actual game data
                gameState.turnCount = restoredTurnCount;
                gameState.isBuyPhase = restoredIsBuyPhase;
                gameState.gameLog = restoredGameLog;
                gameState.firstPlayerId = restoredFirstPlayerId;
                
                // Update players with restored data (keeping colors and layout but changing numbers)
                restoredPlayers.forEach(restoredPlayer => {
                    const currentPlayer = gameState.players.find(p => p.id === restoredPlayer.id);
                    if (currentPlayer) {
                        // Update all the numeric/state values with restored data
                        currentPlayer.life = restoredPlayer.life;
                        currentPlayer.atk = restoredPlayer.atk;
                        currentPlayer.def = restoredPlayer.def;
                        currentPlayer.block = restoredPlayer.block;
                        currentPlayer.leftBlock = restoredPlayer.leftBlock;
                        currentPlayer.rightBlock = restoredPlayer.rightBlock;
                        currentPlayer.isReady = restoredPlayer.isReady;
                        currentPlayer.isDefeated = restoredPlayer.isDefeated;
                        currentPlayer.lastDamageTaken = restoredPlayer.lastDamageTaken;
                        currentPlayer.manualRotation = restoredPlayer.manualRotation;
                        currentPlayer.defeatTaunt = restoredPlayer.defeatTaunt;
                        // Also restore color info to ensure consistency
                        currentPlayer.name = restoredPlayer.name;
                        currentPlayer.name_en = restoredPlayer.name_en;
                        currentPlayer.tailwindClass = restoredPlayer.tailwindClass;
                        currentPlayer.textColorClass = restoredPlayer.textColorClass;
                    }
                });
                
                // Update all cards
                renderAllCards();
                
                // Show game UI
                ui.menuContainer.classList.remove('hidden');
                ui.turnIndicatorContainer.classList.add('hidden');
                updateControlPositions();
                
                // Reset menu position and state
                resetMenuPosition();
                resetMenuFade();
                
                // Update turn indicator
                if (ui.menuTurnBadge) ui.menuTurnBadge.textContent = gameState.turnCount;
                ui.turnLogIndicator.textContent = gameState.turnCount;
                
                // Setup basic content sync without complex layout manipulation
                setTimeout(() => {
                    setupRealTimeContentSync();
                }, 100);
                
                showRestoreNotification();
                
                // Force a render to ensure everything is displayed correctly  
                setTimeout(() => {
                    renderAllCards();
                }, 200);
                
                return true;
            } catch (error) {
                console.error('Failed to restore game state:', error);
                return false;
            }
        };

        const clearSavedGame = () => {
            localStorage.removeItem('crayne_game_state');
        };

        const showRestoreConfirmDialog = (gameData) => {
            return new Promise((resolve) => {
                // Create confirmation dialog
                const dialog = document.createElement('div');
                dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center';
                dialog.style.zIndex = '9999';
                dialog.style.pointerEvents = 'auto';
                dialog.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-md mx-4 shadow-xl" style="z-index: 10000; pointer-events: auto;">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mr-4">
                                <span class="text-2xl">üéÆ</span>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold text-gray-900" data-lang-key="restore_title">Restore Previous Game?</h3>
                                <p class="text-sm text-gray-600" data-lang-key="restore_subtitle">Found saved game data</p>
                            </div>
                        </div>
                        
                        <div class="bg-gray-50 rounded-lg p-4 mb-6">
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>
                                    <span class="text-gray-600" data-lang-key="players">Players:</span>
                                    <span class="font-medium ml-1">${gameData.players.length}</span>
                                </div>
                                <div>
                                    <span class="text-gray-600" data-lang-key="turn">Turn:</span>
                                    <span class="font-medium ml-1">${gameData.turnCount}</span>
                                </div>
                                <div>
                                    <span class="text-gray-600" data-lang-key="layout">Layout:</span>
                                    <span class="font-medium ml-1">${gameData.layoutMode || 'Auto'}</span>
                                </div>
                                <div>
                                    <span class="text-gray-600" data-lang-key="saved">Saved:</span>
                                    <span class="font-medium ml-1">${new Date(gameData.timestamp).toLocaleTimeString()}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex space-x-3">
                            <button id="restore-cancel" class="flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition-colors cursor-pointer" 
                                    style="pointer-events: auto; z-index: 60;" data-lang-key="cancel">
                                Cancel
                            </button>
                            <button id="restore-confirm" class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors cursor-pointer" 
                                    style="pointer-events: auto; z-index: 60;" data-lang-key="restore">
                                Restore Game
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
                // Apply current language
                setLanguage(gameState.currentLang);
                
                // Handle buttons
                const cancelBtn = dialog.querySelector('#restore-cancel');
                const confirmBtn = dialog.querySelector('#restore-confirm');
                
                const cleanup = () => {
                    if (document.body.contains(dialog)) {
                        document.body.removeChild(dialog);
                    }
                };
                
                // Wait for DOM to be ready
                setTimeout(() => {
                    const cancelBtnFinal = dialog.querySelector('#restore-cancel');
                    const confirmBtnFinal = dialog.querySelector('#restore-confirm');
                    
                    if (cancelBtnFinal) {
                        cancelBtnFinal.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            cleanup();
                            resolve(false);
                        });
                        
                        cancelBtnFinal.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            cleanup();
                            resolve(false);
                        });
                    }
                    
                    if (confirmBtnFinal) {
                        confirmBtnFinal.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            cleanup();
                            resolve(true);
                        });
                        
                        confirmBtnFinal.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            cleanup();
                            resolve(true);
                        });
                    }
                }, 10);
                
                // Close on background click
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) {
                        e.preventDefault();
                        e.stopPropagation();
                        cleanup();
                        resolve(false);
                    }
                });
                
                // Keyboard support
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(false);
                        document.removeEventListener('keydown', handleKeydown);
                    } else if (e.key === 'Enter') {
                        cleanup();
                        resolve(true);
                        document.removeEventListener('keydown', handleKeydown);
                    }
                };
                document.addEventListener('keydown', handleKeydown);
            });
        };

        const showRestoreNotification = () => {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-40 transform translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="mr-2">üéÆ</span>
                    <span data-lang-key="game_restored">Game restored successfully!</span>
                </div>
            `;
            
            document.body.appendChild(notification);
            setLanguage(gameState.currentLang);
            
            // Slide in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 10);
            
            // Auto remove
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        };

        
        const ui = {
            playerCountSelector: document.getElementById('player-count'),
            playersContainer: document.getElementById('players-container'),
            startBtn: document.getElementById('start-btn'),
            setupControls: document.getElementById('setup-controls'),
              simpleGameOverModal: document.getElementById('simple-gameover-modal'),
              simpleGameOverMessage: document.getElementById('simple-gameover-message'),
              simpleGameOverClose: document.getElementById('simple-gameover-close'),
              languageSelector: document.getElementById('language-selector'),
              menuContainer: document.getElementById('menu-container'),
              menuBtn: document.getElementById('menu-btn'),
              menuDropdown: document.getElementById('menu-dropdown'),
              menuTurnBadge: document.getElementById('menu-turn-badge'),
              restartGameBtn: document.getElementById('restart-game-btn'),
              toggleFullscreenBtn: document.getElementById('toggle-fullscreen-btn'),
              toggleCountdownBtn: document.getElementById('toggle-countdown-btn'),
              randomBtn: document.getElementById('random-btn'),
              turnLogIndicator: document.getElementById('turn-log-indicator'),
              turnIndicatorContainer: document.getElementById('turn-indicator-container'),
              randomResultBox: document.getElementById('random-result-box'),
              versionDisplay: document.getElementById('version-display'),
              nextTurnContainer: document.getElementById('next-turn-container'),
              nextTurnBtn: document.getElementById('next-turn-btn'),
              undoBtn: document.getElementById('undo-btn'),
              logModal: document.getElementById('log-modal'),
              logContent: document.getElementById('log-content'),
              closeLogBtn: document.getElementById('close-log-btn'),
              openLogBtn: document.getElementById('open-log-btn'),
              colorSelectPanel: document.getElementById('color-select-panel'),
              confirmModal: document.getElementById('confirm-modal'),
              confirmOkBtn: document.getElementById('confirm-ok-btn'),
              confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
              instructionsModal: document.getElementById('instructions-modal'),
              instructionsContent: document.getElementById('instructions-content'),
              closeInstructionsBtn: document.getElementById('close-instructions-btn'),
              instructionsLink: document.getElementById('instructions-link'),
              menuInstructionsBtn: document.getElementById('menu-instructions-btn'),

              noTauntToggle: document.getElementById('no-taunt-toggle'),
              noAutoReadyToggle: document.getElementById('no-auto-ready-toggle')
        };
        
        const shuffleArray = (array) => { const newArr = [...array]; for (let i = newArr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newArr[i], newArr[j]] = [newArr[j], newArr[i]]; } return newArr; };
        const goFullscreen = (orientation = 'landscape') => { 
            const el = document.documentElement;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô iOS ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                         (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
            
            if (el.requestFullscreen) {
                el.requestFullscreen().then(() => {
                    // ‡∏•‡∏î resize trigger ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS
                    if (!isIOS) {
                        setTimeout(() => window.dispatchEvent(new Event('resize')), 200);
                    }
                }).catch(() => {});
            } else if (el.webkitRequestFullscreen) {
                el.webkitRequestFullscreen();
                if (!isIOS) {
                    setTimeout(() => window.dispatchEvent(new Event('resize')), 200);
                }
            }
            
            // ‡πÉ‡∏ô iOS ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á orientation lock ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î 2 ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á
            if (screen.orientation && screen.orientation.lock && !isIOS) {
                screen.orientation.lock(orientation).catch(() => {});
            }
        };
        const getPlayerCountFromLayout = (layout) => parseInt(layout) || 0;

        const manageWakeLock = async (enable) => {
            if ('wakeLock' in navigator) {
                if (enable && !gameState.wakeLockSentinel) {
                    try {
                        gameState.wakeLockSentinel = await navigator.wakeLock.request('screen');
                        gameState.wakeLockSentinel.addEventListener('release', () => {
                            gameState.wakeLockSentinel = null;
                        });
                    } catch (err) {
                        // Wake Lock failed - silently continue
                    }
                } else if (!enable && gameState.wakeLockSentinel) {
                    await gameState.wakeLockSentinel.release();
                    gameState.wakeLockSentinel = null;
                }
            }
        };

        
        function renderColorSelectPanel() {
            const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
            
            const allColors = COLOR_FAMILIES.flat().filter(color =>
            
                !(
                    (color.name_en === 'Violet') ||
                    (color.name_en === 'Teal')
                )
            );
            if (!Array.isArray(gameState.selectedColors)) gameState.selectedColors = [];
            if (gameState.selectedColors.length > count) gameState.selectedColors = gameState.selectedColors.slice(0, count);
            ui.colorSelectPanel.innerHTML = allColors.map(color => {
                const isSelected = gameState.selectedColors.some(sel => sel.name_en === color.name_en);
                return `<button type="button" class="w-8 h-8 rounded-full border-2 ${color.tailwindClass} ${isSelected ? 'ring-4 ring-blue-400' : 'ring-2 ring-gray-200'} transition-all" data-color="${color.name_en}" title="${color.name_en}"></button>`;
            }).join('');
            const selectedCount = gameState.selectedColors.length;
            ui.colorSelectPanel.querySelectorAll('button').forEach(btn => {
                const isDisabled = !gameState.selectedColors.some(s => s.name_en === btn.getAttribute('data-color')) && selectedCount >= count;
                btn.disabled = isDisabled;
                btn.classList.toggle('opacity-40', isDisabled);
                btn.classList.toggle('cursor-not-allowed', isDisabled);
            });
        }

        ui.colorSelectPanel.addEventListener('click', function(e) {
            if (e.target.tagName !== 'BUTTON') return;
            const colorName = e.target.getAttribute('data-color');
            
            const allColors = COLOR_FAMILIES.flat().filter(color =>
                !(color.name_en === 'Violet' || color.name_en === 'Teal')
            );
            const colorObj = allColors.find(c => c.name_en === colorName);
            if (!colorObj) return;
            const idx = gameState.selectedColors.findIndex(c => c.name_en === colorName);
            if (idx >= 0) {
                gameState.selectedColors.splice(idx, 1);
            } else {
                const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
                if (gameState.selectedColors.length < count) {
                    gameState.selectedColors.push(colorObj);
                }
            }
            renderColorSelectPanel();
        });

        function updateColorSelectOnPlayerCountChange() {
            const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
            if (gameState.selectedColors.length > count) {
                gameState.selectedColors = gameState.selectedColors.slice(0, count);
            }
            renderColorSelectPanel();
        }

        
        // ===== TURN ORDER & PAIRING HELPERS =====
        const getTurnOrderHelper = (layoutMode = gameState.layoutMode, playerCount = gameState.initialPlayerCount) => {
            const isBMode = B_MODE_TURN_ORDERS.hasOwnProperty(layoutMode);
            return isBMode ? B_MODE_TURN_ORDERS[layoutMode] : CUSTOM_ORDERS[playerCount] || [];
        };
        
        const getActivePlayerOrder = (activePlayers = null, layoutMode = gameState.layoutMode, playerCount = gameState.initialPlayerCount) => {
            if (!activePlayers) activePlayers = gameState.players.filter(p => !p.isDefeated);
            const order = getTurnOrderHelper(layoutMode, playerCount);
            return order.filter(id => activePlayers.some(p => p.id === id));
        };
        
        const getOpponents = (playerId, activePlayers = null, layoutMode = gameState.layoutMode) => {
            // ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏ö‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏° (circular) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å layout ‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡πÄ‡∏Å‡∏°‡∏ó‡∏µ‡πà‡∏ô‡∏±‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°
            const activePlayerOrder = getActivePlayerOrder(activePlayers, layoutMode);
            const currentIndex = activePlayerOrder.indexOf(playerId);
            if (currentIndex === -1) return { left: null, right: null };
            return {
                left: gameState.players.find(p => p.id === activePlayerOrder[(currentIndex + 1) % activePlayerOrder.length]),
                right: gameState.players.find(p => p.id === activePlayerOrder[(currentIndex - 1 + activePlayerOrder.length) % activePlayerOrder.length])
            };
        };

        // ===== LAYOUT CONFIGURATION =====
        const LAYOUT_CONFIG = {
            // Standard layouts (2-6 players)
            '2': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'  // Top half rotated 180deg
            },
            '3': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            '4': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            
            // B Mode layouts (using standard layout now)
            '3B': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            '5B': { 
                type: 'standard', cssClass: 'layout-5p', needsRotation: true,
                gridPositions: { 2: 'col-start-1 row-start-1', 3: 'col-start-2 row-start-1', 4: 'col-start-1 row-start-2', 5: 'col-start-2 row-start-2', 6: 'col-span-2 row-start-3' },
                rotations: { 2: 'rotate-90', 3: '-rotate-90', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '5C': { 
                type: 'standard', cssClass: 'layout-5p', needsRotation: true,
                gridPositions: { 2: 'col-start-1 row-start-1', 3: 'col-start-2 row-start-1', 4: 'col-start-1 row-start-2', 5: 'col-start-2 row-start-2', 6: 'col-span-2 row-start-3' },
                rotations: { 2: 'rotate-180', 3: 'rotate-180', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '6B': { 
                type: 'standard', cssClass: 'layout-6b', needsRotation: true,
                gridPositions: { 1: 'col-span-2 row-start-1', 2: 'col-start-1 row-start-2', 3: 'col-start-2 row-start-2', 4: 'col-start-1 row-start-3', 5: 'col-start-2 row-start-3', 6: 'col-span-2 row-start-4' },
                rotations: { 1: 'rotate-180', 2: 'rotate-90', 3: '-rotate-90', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '6C': { 
                type: 'standard', cssClass: '', needsRotation: true,
                gridPositions: { 1: 'col-start-1 row-start-1', 2: 'col-start-2 row-start-1', 3: 'col-start-1 row-start-2', 4: 'col-start-2 row-start-2', 5: 'col-start-1 row-start-3', 6: 'col-start-2 row-start-3' },
                rotations: { 1: 'rotate-180', 2: 'rotate-180', 3: 'rotate-90', 4: '-rotate-90', 5: '', 6: '' }
            }
        };

        const getFontSizes = (layoutMode, playerCount) => {
            const isTwoPlayerMode = playerCount === 2;
            
            // All modes now use responsive sizing
            const base = {
                    stats: 'text-2xl sm:text-3xl md:text-4xl font-bold',
                    block: 'text-xl sm:text-2xl font-bold',
                    blockInCircle: 'text-lg sm:text-xl font-bold',
                    label: 'text-xs', readyBtn: 'p-2 text-sm',
                    smallBtn: 'w-4 h-4 sm:w-5 sm:h-5',
                    mediumBtn: 'w-5 h-5 sm:w-6 sm:h-6',
                    largeBtn: 'w-8 h-8 sm:w-9 sm:h-9 text-xl',
                    rotateBtn: 'w-8 h-8 sm:w-9 sm:h-9'
                };
                
                if (isTwoPlayerMode) {
                    return Object.assign(base, {
                        stats: 'text-6xl font-bold', block: 'text-4xl font-bold',
                        blockInCircle: 'text-3xl font-bold',
                        label: 'text-lg', readyBtn: 'p-3 text-lg',
                        smallBtn: 'w-8 h-8', mediumBtn: 'w-10 h-10',
                        largeBtn: 'w-10 h-10 text-3xl',
                        rotateBtn: 'w-8 h-8',
                        statsWidth: 'w-20' // Wider for 2-digit numbers in large font
                    });
                }
                
                // Standard multi-player width
                base.statsWidth = 'w-10';
                return base;
        };

        const renderAllCards = () => gameState.players.filter(p => !p.isInitiallyDefeated).forEach(updatePlayerCard);

        const createPlayerCardHTML = (player, layoutMode) => {
            const config = LAYOUT_CONFIG[layoutMode];
            const fontSizes = getFontSizes(layoutMode, gameState.initialPlayerCount);
            
            // All layouts now use standard layout with unified positioning
            return `<div class="relative p-1 flex flex-col h-full overflow-hidden">
                    
                    <!-- Block controls ‡∏≠‡∏¥‡∏™‡∏£‡∏∞‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏ö‡∏ö‡∏ô‡∏ã‡πâ‡∏≤‡∏¢/‡∏Ç‡∏ß‡∏≤ -->
                    <div class="absolute top-1 left-1 right-1 flex justify-between items-start pointer-events-none" style="z-index: 30;">
                        <!-- DUAL BLOCK UI -->
                        <div class="dual-block-ui flex justify-between w-full">
                            <div class="flex flex-col items-center">
                                <div class="flex items-center mt-1 relative">
                                    <button data-player-id="${player.id}" data-action="decrement-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">-</button>
                                    <div class="left-opponent-indicator w-7 h-7 mx-1 rounded-full ring-2 ring-white flex items-center justify-center">
                                        <span class="left-block-display ${fontSizes.blockInCircle} text-white font-bold drop-shadow-lg">0</span>
                                    </div>
                                    <button data-player-id="${player.id}" data-action="increment-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">+</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-center">
                                <div class="flex items-center mt-1 relative">
                                    <button data-player-id="${player.id}" data-action="decrement-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">-</button>
                                    <div class="right-opponent-indicator w-7 h-7 mx-1 rounded-full ring-2 ring-white flex items-center justify-center">
                                        <span class="right-block-display ${fontSizes.blockInCircle} text-white font-bold drop-shadow-lg">0</span>
                                    </div>
                                    <button data-player-id="${player.id}" data-action="increment-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">+</button>
                                </div>
                            </div>
                        </div>
                        <div class="single-block-ui hidden justify-center w-full">
                            <div class="flex flex-col items-center">
                                <div class="flex items-center mt-1 relative">
                                    <button data-player-id="${player.id}" data-action="decrement-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">-</button>
                                    <span class="block-display ${fontSizes.block} w-20 text-center">0</span>
                                    <button data-player-id="${player.id}" data-action="increment-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full" style="pointer-events: auto;">+</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Center area: Life display with Ready functionality -->
                    <div class="relative flex-grow flex flex-col items-center justify-center min-h-0" style="z-index: 25;">
                        <!-- Life display ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏£‡∏¥‡∏á‡πÜ -->
                        <div class="life-display font-extrabold text-white text-center transition-all duration-300 relative">60</div>
                        
                        <!-- Ready indicator - icon ‡∏î‡∏≤‡∏ö‡∏ó‡∏±‡∏ö Life display -->
                        <div class="ready-indicator absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-0 transition-all duration-300 pointer-events-none" style="z-index: 26;">‚öîÔ∏è</div>
                        
                        <!-- ‡∏õ‡∏∏‡πà‡∏° Ready ‡∏ó‡∏µ‡πà scale ‡∏ï‡∏≤‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç Life -->
                        <button data-player-id="${player.id}" data-action="ready" class="ready-life-btn absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-transparent" style="z-index: 27; pointer-events: auto;" title="Toggle Ready"></button>
                    </div>
                    
                    <!-- Life controls ‡∏Ç‡πâ‡∏≤‡∏á‡πÜ ‡∏Å‡∏•‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î -->
                    <div class="absolute left-2 right-2 top-1/2 -translate-y-1/2 flex items-center justify-between pointer-events-none" style="z-index: 35;">
                        <button data-player-id="${player.id}" data-action="decrement-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-red-500 bg-opacity-80 rounded-full" style="pointer-events: auto;">-</button>
                        <button data-player-id="${player.id}" data-action="increment-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-green-500 bg-opacity-80 rounded-full" style="pointer-events: auto;">+</button>
                    </div>
                    
                    <!-- Bottom corners: ATK ‡∏ã‡πâ‡∏≤‡∏¢, DEF ‡∏Ç‡∏ß‡∏≤ -->
                    <div class="absolute bottom-1 left-1 right-1 flex justify-between items-end pointer-events-none" style="z-index: 40;">
                        <!-- ATK - ‡∏ä‡∏¥‡∏î‡∏•‡πà‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢ -->
                        <div class="flex flex-col items-center">
                            <div class="flex items-center gap-0">
                                <button data-player-id="${player.id}" data-action="decrement-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 rounded-full -mr-2" style="pointer-events: auto; z-index: 39;">-</button>
                                <div class="atk-icon-container" style="z-index: 38;">
                                    <svg viewBox="0 0 100 100" aria-label="ATK">
                                        <rect x="36" y="47" width="58" height="6" fill="#d09d81" stroke="#374151" stroke-width="4"/>
                                        <path fill="#d09d81" stroke="#62645c" stroke-width="4" d="M50,12 L66,18 L78,30 L70,46 L50,52 L30,46 L22,30 L34,18 Z M50,88 L66,82 L78,70 L70,54 L50,48 L30,54 L22,70 L34,82 Z"/>
                                    </svg>
                                    <span class="atk-display">0</span>
                                </div>
                                <button data-player-id="${player.id}" data-action="increment-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 rounded-full -ml-2" style="pointer-events: auto; z-index: 39;">+</button>
                            </div>
                        </div>
                        
                        <!-- DEF - ‡∏ä‡∏¥‡∏î‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤ -->
                        <div class="flex flex-col items-center">
                            <div class="flex items-center gap-0">
                                <button data-player-id="${player.id}" data-action="decrement-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 rounded-full -mr-2" style="pointer-events: auto; z-index: 39;">-</button>
                                <div class="def-icon-container" style="z-index: 41;">
                                    <svg viewBox="0 0 100 100" aria-label="DEF">
                                        <path fill="#d09d81" stroke="#62645c" stroke-width="4" d="M50 15 L18 30 L25 75 L50 85 L75 75 L82 30 Z"/>
                                    </svg>
                                    <span class="def-display">0</span>
                                </div>
                                <button data-player-id="${player.id}" data-action="increment-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 rounded-full -ml-2" style="pointer-events: auto; z-index: 39;">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Rotation Button - only in first turn -->
                    <div class="rotation-btn absolute ${gameState.initialPlayerCount === 2 ? 'top-12' : 'top-5'} left-1/2 transform -translate-x-1/2 hidden" style="z-index: 32;">
                        <button data-player-id="${player.id}" data-action="rotate" class="${fontSizes.rotateBtn} bg-gradient-to-br from-blue-400 to-blue-600 hover:from-blue-500 hover:to-blue-700 rounded-full text-white font-bold shadow-lg hover:shadow-xl transition-all duration-200 flex items-center justify-center" style="pointer-events: auto; font-size: 16px;" title="Rotate Card 90¬∞">
                            <span class="rotate-icon">‚Üª</span>
                        </button>
                    </div>
                    
                    <!-- First Player Token - ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á life ‡πÅ‡∏•‡∏∞ ATK/DEF -->
                    <div class="first-player-token absolute ${gameState.initialPlayerCount === 2 || gameState.initialPlayerCount === 3|| gameState.initialPlayerCount === 4 ? 'bottom-8' : 'bottom-5'} left-1/2 -translate-x-1/2 w-9 h-9 rounded-full bg-gradient-to-br from-yellow-300 to-yellow-500 border-2 border-yellow-600 shadow-lg hidden items-center justify-center" style="z-index: 35;">
                        <span class="text-lg">üëë</span>
                    </div>
                    
                    <!-- Damage display - ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏¢‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏á -->
                    <div class="absolute ${gameState.initialPlayerCount=== 2? 'top-1/4' : 'top-5'} left-1/2 -translate-x-1/2" style="z-index: 30;">
                        <div class="damage-container text-center"></div>
                    </div>
                </div>`;
        };

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏µ‡∏Å‡∏≤‡∏£‡πå‡∏î
        const syncContentAreaWithCardBackground = (card) => {
            if (!card) return;
            
            const contentWrapper = card.querySelector('.content-wrapper');
            const rotator = card.querySelector('.rotator');
            if (!contentWrapper) return;
            
            // ‡∏£‡∏≠‡πÉ‡∏´‡πâ DOM ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä
            requestAnimationFrame(() => {
                const cardRect = card.getBoundingClientRect();
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á‡∏Ç‡∏≠‡∏á‡∏™‡∏µ‡∏Å‡∏≤‡∏£‡πå‡∏î (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏° padding/margin)
                const actualWidth = cardRect.width;
                const actualHeight = cardRect.height;

                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì padding ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏≠‡∏ö‡∏ã‡πâ‡∏≤‡∏¢/‡∏Ç‡∏ß‡∏≤ ‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏ä‡∏¥‡∏î‡∏Ç‡∏≠‡∏ö
                const computed = window.getComputedStyle(contentWrapper);
                const padL = parseFloat(computed.paddingLeft) || 0;
                const padR = parseFloat(computed.paddingRight) || 0;
                const innerWidth = Math.max(0, actualWidth - padL - padR);
                
                // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ content area ‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πå‡∏î
                contentWrapper.style.width = `${actualWidth}px`;
                contentWrapper.style.height = `${actualHeight}px`;
                contentWrapper.style.maxWidth = `${actualWidth}px`;
                contentWrapper.style.maxHeight = `${actualHeight}px`;
                contentWrapper.style.position = 'absolute';
                contentWrapper.style.top = '0';
                contentWrapper.style.left = '0';
                contentWrapper.style.boxSizing = 'border-box';

                // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î .rotator ‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô ¬±90¬∞ ‡πÇ‡∏î‡∏¢‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏ß‡πâ‡∏≤‡∏á/‡∏™‡∏π‡∏á
                if (rotator) {
                    let playerId = null;
                    if (card.id && card.id.startsWith('player-card-')) {
                        playerId = parseInt(card.id.replace('player-card-', ''), 10);
                    }
                    let rotation = '';
                    const config = LAYOUT_CONFIG[gameState.layoutMode];
                    if (config?.rotations) {
                        rotation = config.rotations[playerId] || '';
                    } else if (config?.rotationRule === 'top-half') {
                        const playerCount = getPlayerCountFromLayout(gameState.layoutMode);
                        const shouldRotate = (playerCount === 2 ? playerId === 1 : playerId <= Math.ceil(playerCount / 2));
                        rotation = shouldRotate ? 'rotate-180' : '';
                    }
                    let deg = rotation ? parseInt(rotation.replace('rotate-', ''), 10) : 0;
                    
                    // Add manual rotation from player
                    const player = gameState.players.find(p => p.id === playerId);
                    if (player && player.manualRotation) {
                        deg += player.manualRotation;
                    }

                    if (Math.abs(deg) % 180 === 90) {
                        // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô 90/270 ‡∏≠‡∏á‡∏®‡∏≤ ‡∏Å‡∏ß‡πâ‡∏≤‡∏á/‡∏™‡∏π‡∏á‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô ‡πÉ‡∏ä‡πâ innerWidth ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏≤‡∏£‡∏û padding ‡∏ã‡πâ‡∏≤‡∏¢/‡∏Ç‡∏ß‡∏≤
                        rotator.style.width = `${actualHeight}px`;
                        rotator.style.height = `${innerWidth}px`;
                    } else {
                        rotator.style.width = `${innerWidth}px`;
                        rotator.style.height = `${actualHeight}px`;
                    }
                    rotator.style.position = 'absolute';
                    rotator.style.top = '50%';
                    rotator.style.left = '50%';
                    rotator.style.transformOrigin = 'center center';
                    rotator.style.transform = `translate(-50%, -50%)${deg ? ` rotate(${deg}deg)` : ''}`;
                }
                
                // Synced content area dimensions
            });
        };
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
        const setupRealTimeContentSync = () => {
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver(entries => {
                    entries.forEach(entry => {
                        const card = entry.target;
                        if (card.classList.contains('player-card') || card.id && card.id.startsWith('player-card-')) {
                            syncContentAreaWithCardBackground(card);
                        }
                    });
                });
                
                // ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                gameState.players.forEach(player => {
                    const card = document.getElementById(`player-card-${player.id}`);
                    if (card) {
                        resizeObserver.observe(card);
                    }
                });
                
                gameState.contentResizeObserver = resizeObserver;
            }
        };

        const createPlayerCard = (player) => {
            const card = document.createElement('div');
            card.id = `player-card-${player.id}`;
            card.style.position = 'relative';
            card.innerHTML = `<div class="content-wrapper"><div class="rotator">${createPlayerCardHTML(player, gameState.layoutMode)}<div class="defeated-overlay" style="display: none;"><span class="text-2xl" data-lang-key="defeated"></span><span class="taunt-text text-xl font-black mt-2" style="color: #ffffff !important; text-shadow: 3px 3px 6px rgba(0,0,0,1), -1px -1px 2px rgba(0,0,0,0.8) !important; filter: none !important;"></span></div></div></div>`;
            return card;
        };
        
        // ===== HTML HELPERS - CONSOLIDATED =====
        const updatePlayerCard = player => safe(() => {
            const card = $(`#player-card-${player.id}`);
            if (!card) return;
            [_updateBlockVisibility, _updateCardLayout, _updateCardState, syncContentAreaWithCardBackground, 
             _updateCardData, _updateOpponentIndicators, _updateCardControls, _updateFirstPlayerToken].forEach(fn => fn(card, player));
        });

        const _updateBlockVisibility = (card) => {
            const activePlayersCount = gameState.players.filter(p => !p.isDefeated).length;
            const singleBlockUI = card.querySelector('.single-block-ui');
            const dualBlockUI = card.querySelector('.dual-block-ui');
            if (!singleBlockUI || !dualBlockUI) return;
            const showSingle = activePlayersCount <= 2;
            singleBlockUI.classList.toggle('hidden', !showSingle);
            dualBlockUI.classList.toggle('hidden', showSingle);
        };

        // ‡∏•‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß - ‡πÉ‡∏ä‡πâ CSS ‡πÅ‡∏•‡∏∞ transform ‡πÉ‡∏ô _updateCardLayout ‡πÅ‡∏ó‡∏ô

        const _updateCardLayout = (card, player) => {
            let baseClasses = `${player.tailwindClass} text-white shadow-xl relative overflow-hidden flex`;
            const config = LAYOUT_CONFIG[gameState.layoutMode];
            const contentWrapper = card.querySelector('.content-wrapper');
            
            // Get grid position from config
            let gridPosition = config?.gridPositions?.[player.id] || '';
            
            // Get rotation from config
            let rotation = '';
            if (config?.rotations) {
                // Use specific rotations from config
                rotation = config.rotations[player.id] || '';
            } else if (config?.rotationRule === 'top-half') {
                // Use top-half rotation rule
                const playerCount = getPlayerCountFromLayout(gameState.layoutMode);
                rotation = (playerCount === 2 ? player.id === 1 : player.id <= Math.ceil(playerCount / 2)) ? 'rotate-180' : '';
            }

            card.className = `${baseClasses} ${gridPosition}`;
            const rotator = card.querySelector('.rotator');
            if (rotator) {
                let deg = rotation ? parseInt(rotation.replace('rotate-', ''), 10) : 0;
                
                // Add manual rotation from player
                if (player.manualRotation) {
                    deg += player.manualRotation;
                }
                
                rotator.style.transform = `translate(-50%, -50%)${deg ? ` rotate(${deg}deg)` : ''}`;
            }
            
            // Apply layout-specific CSS classes from config
            if (config?.cssClass) {
                contentWrapper.classList.add(config.cssClass);
            }
            // ‡∏•‡∏ö CSS class ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß - ‡πÉ‡∏ä‡πâ transform ‡πÉ‡∏ô style ‡πÅ‡∏ó‡∏ô
        };

        const _updateCardState = (card, player) => {
            const defeatedOverlay = card.querySelector('.defeated-overlay');
            if (player.isDefeated) {
                card.classList.add('opacity-40');
                defeatedOverlay.style.display = 'flex';
                defeatedOverlay.querySelector('.taunt-text').textContent = player.defeatTaunt || '';
            } else {
                card.classList.remove('opacity-40');
                defeatedOverlay.style.display = 'none';
            }
        };

        const _updateCardData = (card, player) => {
            card.querySelector('.life-display').textContent = player.life;
            card.querySelector('.life-display').classList.toggle('first-player-highlight', player.id === gameState.firstPlayerId && !player.isDefeated);
            card.querySelector('.atk-display').textContent = player.atk;
            card.querySelector('.def-display').textContent = player.def;
            const blockDisplay = card.querySelector('.block-display');
            if (blockDisplay) blockDisplay.textContent = player.block;
            const leftBlockDisplay = card.querySelector('.left-block-display');
            if(leftBlockDisplay) leftBlockDisplay.textContent = player.leftBlock;
            const rightBlockDisplay = card.querySelector('.right-block-display');
            if(rightBlockDisplay) rightBlockDisplay.textContent = player.rightBlock;
            const damageContainer = card.querySelector('.damage-container');
            const damageFontSize = ['6B', '6C', '5B', '5C', '3B'].includes(gameState.layoutMode) ? 'text-5xl' : 'text-4xl';
            damageContainer.innerHTML = (player.lastDamageTaken > 0 && gameState.isBuyPhase) ? `<span class="damage-display ${damageFontSize} font-bold">-${player.lastDamageTaken}</span>` : '';
        };

        const _updateOpponentIndicators = (card, player) => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length <= 2) {
                const leftIndicator = card.querySelector('.left-opponent-indicator');
                if (leftIndicator) leftIndicator.classList.add('hidden');
                const rightIndicator = card.querySelector('.right-opponent-indicator');
                if (rightIndicator) rightIndicator.classList.add('hidden');
                return;
            };

            const leftIndicator = card.querySelector('.left-opponent-indicator');
            if(leftIndicator) leftIndicator.classList.remove('hidden');
            const rightIndicator = card.querySelector('.right-opponent-indicator');
            if(rightIndicator) rightIndicator.classList.remove('hidden');

            const config = LAYOUT_CONFIG[gameState.layoutMode];
            const opponents = getOpponents(player.id, activePlayers);
            let leftOpponent = opponents.left, rightOpponent = opponents.right;
            
            // ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÅ‡∏ï‡πà‡∏Ç‡∏ô‡∏≤‡∏î w-8 h-8 ‡πÅ‡∏ó‡∏ô w-3 h-3
            if (leftIndicator) leftIndicator.className = `left-opponent-indicator w-7 h-7 mx-1 rounded-full ring-2 ring-white flex items-center justify-center ${leftOpponent ? leftOpponent.tailwindClass : 'bg-transparent'}`;
            if (rightIndicator) rightIndicator.className = `right-opponent-indicator w-7 h-7 mx-1 rounded-full ring-2 ring-white flex items-center justify-center ${rightOpponent ? rightOpponent.tailwindClass : 'bg-transparent'}`;
        };

        const _updateCardControls = (card, player) => {
            // Update Ready state for Life display
            const lifeDisplay = card.querySelector('.life-display');
            const readyIndicator = card.querySelector('.ready-indicator');
            const readyLifeBtn = card.querySelector('.ready-life-btn');
            
            if (lifeDisplay) {
                lifeDisplay.classList.toggle('ready', player.isReady);
            }
            
            if (readyIndicator) {
                readyIndicator.classList.toggle('active', player.isReady && !player.isDefeated);
            }
            
            if (readyLifeBtn) {
                readyLifeBtn.disabled = player.isDefeated || gameState.isBuyPhase;
            }
            
            // Show/hide rotation button based on turn
            const rotationBtn = card.querySelector('.rotation-btn');
            if (rotationBtn) {
                if (gameState.turnCount === 1 && !gameState.isBuyPhase) {
                    rotationBtn.classList.remove('hidden');
                } else {
                    rotationBtn.classList.add('hidden');
                }
            }
            
            const shouldLock = player.isDefeated || player.isReady || gameState.isBuyPhase;
            card.querySelectorAll(`[data-action$="-atk"], [data-action$="-def"], [data-action*="Block"], [data-action="rotate"]`).forEach(btn => btn.disabled = shouldLock);
            card.querySelectorAll(`[data-action$="-life"]`).forEach(btn => btn.disabled = player.isDefeated);
        };

        const _updateFirstPlayerToken = (card, player) => {
            const token = card.querySelector('.first-player-token');
            if (token) {
                const isFirstPlayer = gameState.firstPlayerId === player.id;
                token.classList.toggle('hidden', !isFirstPlayer);
                token.classList.toggle('flex', isFirstPlayer);
            }
        };

        const showLifeChangeIndicator = (playerId, totalChange) => {
            const card = document.getElementById(`player-card-${playerId}`);
            if (!card || totalChange === 0) return;
            let indicator = card.querySelector('.life-change-indicator');
            if (indicator) indicator.remove();
            indicator = document.createElement('div');
            indicator.className = 'life-change-indicator';
            indicator.textContent = `${totalChange > 0 ? '+' : ''}${totalChange}`;
            indicator.style.color = totalChange > 0 ? '#a7f3d0' : '#fecaca';
            const contentWrapper = card.querySelector('.content-wrapper > div');
            if (contentWrapper) {
                contentWrapper.appendChild(indicator);
                setTimeout(() => indicator.remove(), 1400);
            }
        };

        const setLanguage = (lang) => {
            gameState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const translation = TRANSLATIONS[lang][el.dataset.langKey];
                if (translation && typeof translation === 'string') el.textContent = translation;
            });
            if (ui.simpleGameOverClose) ui.simpleGameOverClose.textContent = TRANSLATIONS[lang].newGameButton || 'New Game';
            if (gameState.players.length > 0) renderAllCards();
        };
        
        // ===== UTILITY FUNCTIONS - CONSOLIDATED =====
        const logEvent = (message) => gameState.gameLog.push(message);
        const updateLogModal = () => { ui.logContent.innerHTML = gameState.gameLog.map(e => `<p class="text-sm text-gray-600 mb-1">${e}</p>`).join(''); ui.logContent.scrollTop = ui.logContent.scrollHeight; };
        const updateInstructionsContent = () => ui.instructionsContent.innerHTML = INSTRUCTIONS_CONTENT[gameState.currentLang || 'th'] || INSTRUCTIONS_CONTENT.th;
        const updateControlPositions = () => ui.turnIndicatorContainer.classList.toggle('top-center', ['3B', '5B', '5C', '6C'].includes(gameState.layoutMode));
        const resetPlayerTurnStats = () => {
            // Clear all auto ready timers when resetting turn stats
            gameState.autoReadyTimers.forEach(clearTimeout);
            gameState.autoReadyTimers.clear();
            gameState.players.forEach(p => { 
                if (!p.isDefeated) Object.assign(p, { atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0 }); 
            });
        };
        const checkAllReady = () => { 
            const activePlayers = gameState.players.filter(p => !p.isDefeated); 
            if (activePlayers.length > 0 && activePlayers.every(p => p.isReady)) handleRoundEnd(); 
        };

        const startGame = () => {
            gameState.layoutMode = ui.playerCountSelector.value;
            gameState.initialPlayerCount = getPlayerCountFromLayout(gameState.layoutMode);
            if (gameState.selectedColors.length !== gameState.initialPlayerCount) return alert('Please select exactly ' + gameState.initialPlayerCount + ' colors.');
            initPlayers();
            updateControlPositions();
            ui.setupControls.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden');
            ui.turnIndicatorContainer.classList.add('hidden');
            resetMenuPosition();
            resetMenuFade();
            
            // ‡πÄ‡∏õ‡∏¥‡∏î wake lock ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
            manageWakeLock(true);
            
            // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö sync ‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
            setTimeout(() => {
                setupRealTimeContentSync();
                // Sync ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                gameState.players.forEach(player => {
                    const card = document.getElementById(`player-card-${player.id}`);
                    if (card) syncContentAreaWithCardBackground(card);
                });
            }, CONFIG.DELAYS.SYNC_TIMEOUT);
        };

        // ‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á burger menu ‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠ (default)
        const resetMenuPosition = () => {
            const m = ui.menuContainer;
            if (!m) return;
            
            // ‡∏•‡πâ‡∏≤‡∏á positioning classes ‡πÅ‡∏•‡∏∞ inline styles
            m.classList.remove('position-left', 'position-right', 'position-top', 'position-bottom');
            m.style.left = '';
            m.style.top = '';
            m.style.right = '';
            m.style.bottom = '';
            m.style.transform = '';
            
            // CSS ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (center-screen) ‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
        };

        // ===== Menu fade utilities =====
        const setMenuFaded = (state) => {
            if (!ui.menuContainer) return;
            ui.menuContainer.classList.toggle('faded', !!state);
            gameState.menuFaded = !!state;
        };
        const scheduleMenuFade = () => {
            if (gameState.menuFadeTimer) {
                clearTimeout(gameState.menuFadeTimer);
                gameState.activeTimeouts.delete(gameState.menuFadeTimer);
            }
            // ‡∏≠‡∏¢‡πà‡∏≤‡∏à‡∏≤‡∏á‡∏Ç‡∏ì‡∏∞‡∏•‡∏≤‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏ì‡∏∞‡πÄ‡∏õ‡∏¥‡∏î dropdown
            gameState.menuFadeTimer = safeTimeout(() => {
                if (!gameState.isDragging && !ui.menuDropdown.classList.contains('active')) {
                    setMenuFaded(true);
                }
            }, CONFIG.UI.MENU_FADE_TIMEOUT, 'menuFade');
            gameState.activeTimeouts.add(gameState.menuFadeTimer);
        };
        const resetMenuFade = () => {
            setMenuFaded(false);
            scheduleMenuFade();
        };

        // ===== CLEANUP =====
        const cleanup = () => {
            gameState.activeTimeouts.forEach(clearTimeout);
            gameState.activeTimeouts.clear();
            gameState.autoReadyTimers.forEach(clearTimeout);
            gameState.autoReadyTimers.clear();
            if (gameState.contentResizeObserver) gameState.contentResizeObserver.disconnect();
            if (gameState.menuFadeTimer) clearTimeout(gameState.menuFadeTimer);
        };

        // ===== AUTO READY SYSTEM =====
        const scheduleAutoReady = (playerId) => {
            // Check if auto ready is disabled
            if (ui.noAutoReadyToggle?.checked || !gameState.countdownEnabled) {
                return; // Skip auto ready if disabled
            }
            
            clearAutoReady(playerId);
            
            const timer = setTimeout(() => {
                const player = gameState.players.find(p => p.id === playerId);
                if (player && !player.isDefeated && !player.isReady && !gameState.isBuyPhase) {
                    performPlayerAction(playerId, 'ready');
                }
                gameState.autoReadyTimers.delete(playerId);
            }, CONFIG.DELAYS.AUTO_READY);
            gameState.autoReadyTimers.set(playerId, timer);
        };

        const clearAutoReady = (playerId) => {
            const timer = gameState.autoReadyTimers.get(playerId);
            if (timer) {
                clearTimeout(timer);
                gameState.autoReadyTimers.delete(playerId);
            }
        };

        const resetGame = () => safe(() => {
            cleanup();
            
            // Clear save timeout and saved game data
            if (gameState.saveTimeout) {
                clearTimeout(gameState.saveTimeout);
                gameState.saveTimeout = null;
            }
            clearSavedGame();
            
            // ‡∏õ‡∏¥‡∏î wake lock ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏Å‡∏°
            manageWakeLock(false);
            
            Object.assign(gameState, { players: [], initialPlayerCount: 0, layoutMode: null, firstPlayerId: null, 
                isBuyPhase: false, turnCount: 0, gameLog: [], previewColors: [], previousPlayerState: null });
            updateControlPositions();
            ['nextTurnContainer', 'menuContainer', 'turnIndicatorContainer'].forEach(el => ui[el].classList.add('hidden'));
            ['playersContainer'].forEach(el => ui[el].innerHTML = '');
            ui.setupControls.classList.remove('hidden');
            if (document.fullscreenElement) safe(() => document.exitFullscreen());
            setLanguage(gameState.currentLang);
            setMenuFaded(false);
        });
        
        const initPlayers = () => {
            const isBMode = ['6B', '5B', '5C'].includes(gameState.layoutMode);
            const defaultStats = { life: CONFIG.STARTING_LIFE.default, isDefeated: false, isInitiallyDefeated: false, 
                atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0, manualRotation: 0, defeatTaunt: null };
            let gameColors = shuffleArray([...gameState.selectedColors]);
            
            if (['5B', '5C'].includes(gameState.layoutMode)) {
                gameState.players = [{ id: 1, ...COLOR_FAMILIES[0][0], life: 0, isDefeated: true, isInitiallyDefeated: true, ...defaultStats, life: 0, isDefeated: true },
                    ...[2,3,4,5,6].map((id, idx) => ({ id, ...gameColors[idx], ...defaultStats }))];
            } else if (isBMode) {
                const allColors = COLOR_FAMILIES.map(f => f[0]);
                while (gameColors.length < 6) {
                    const unused = allColors.filter(c => !gameColors.some(s => s.name_en === c.name_en));
                    if (unused.length) gameColors.push(unused[Math.floor(Math.random() * unused.length)]);
                    else break;
                }
                gameState.players = Array.from({ length: 6 }, (_, i) => ({ id: i + 1, ...gameColors[i], ...defaultStats }));
            } else {
                gameState.players = Array.from({ length: gameState.initialPlayerCount }, (_, i) => ({ id: i + 1, ...gameColors[i], ...defaultStats }));
            }
            if (gameState.initialPlayerCount === 2) gameState.players.forEach(p => p.life = CONFIG.STARTING_LIFE[2]);
            
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length > 0) gameState.firstPlayerId = activePlayers[Math.floor(Math.random() * activePlayers.length)].id;
            gameState.turnCount = 1;
            ui.turnLogIndicator.textContent = gameState.turnCount;
            if (ui.menuTurnBadge) ui.menuTurnBadge.textContent = String(gameState.turnCount);
            gameState.gameLog = [];
            logEvent(`<strong>Game Started with ${activePlayers.length} players (Mode: ${gameState.layoutMode}).</strong>`);
            logEvent(`<strong>--- ${TRANSLATIONS[gameState.currentLang].logTurn(gameState.turnCount)} ---</strong>`);
            
            ui.playersContainer.innerHTML = '';
            ui.playersContainer.style.gridTemplateRows = '';
            ui.playersContainer.className = 'w-full h-full flex-grow grid min-h-0';

            if (gameState.layoutMode === '6B') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-4');
                ui.playersContainer.style.gridTemplateRows = '1fr 1.5fr 1.5fr 1fr';
            } else if (gameState.layoutMode === '6C') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-3');
                ui.playersContainer.style.gridTemplateRows = '1fr 1fr 1fr';
            } else if (gameState.layoutMode === '5B' || gameState.layoutMode === '5C') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-3');
                ui.playersContainer.style.gridTemplateRows = '1.3fr 1.3fr 1.4fr';
            } else if (gameState.initialPlayerCount === 7) {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-4');
                ui.playersContainer.style.gridTemplateRows = '1fr 1fr 1fr 1fr';
            } else if (gameState.initialPlayerCount === 8) {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-4');
                ui.playersContainer.style.gridTemplateRows = '1fr 1fr 1fr 1fr';
            } else {
                let gridClass = 'grid-cols-2';
                if (gameState.initialPlayerCount <= 2) gridClass = 'grid-cols-1';
                if (gameState.initialPlayerCount === 3) gridClass = 'grid-cols-2';
                if (gameState.initialPlayerCount === 4) gridClass = 'grid-cols-2';
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö layout ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (7, 8 ‡∏Ñ‡∏ô) ‡πÉ‡∏ä‡πâ grid-cols-2
                ui.playersContainer.classList.add(...gridClass.split(' '));
            }

            
            let playersToRender = gameState.players.filter(p => !p.isInitiallyDefeated);
            if (gameState.layoutMode === '5B' || gameState.layoutMode === '5C') {
                playersToRender = playersToRender.filter(p => p.id !== 1);
            }
            if (gameState.layoutMode === '3') {
                playersToRender.forEach((player) => {
                    const card = createPlayerCard(player);
                    // Player 1 ‡πÅ‡∏•‡∏∞ 2 ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏ñ‡∏ß‡∏ö‡∏ô, Player 3 ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏ñ‡∏ß‡∏•‡πà‡∏≤‡∏á
                    if (player.id <= 2) {
                        card.classList.add('col-span-1', 'row-start-1');
                    } else {
                        card.classList.add('col-span-2', 'row-start-2');
                        card.style.width = "100%";
                        card.style.gridColumn = "1 / span 2";
                    }
                    ui.playersContainer.appendChild(card);
                    updatePlayerCard(player);
                });
            } else if (gameState.initialPlayerCount === 7) {
                playersToRender.forEach((player) => {
                    const card = createPlayerCard(player);
                    // Player 7 (‡πÅ‡∏ñ‡∏ß‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î) ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î
                    if (player.id === 7) {
                        card.classList.add('col-span-2');
                        card.style.gridColumn = "1 / span 2";
                    }
                    ui.playersContainer.appendChild(card);
                });
            } else {
                playersToRender.forEach((player) => {
                    ui.playersContainer.appendChild(createPlayerCard(player));
                });
            }
            
            // Update countdown button text
            ui.toggleCountdownBtn.textContent = gameState.countdownEnabled ? '‚è±Ô∏è Auto ON' : '‚è±Ô∏è Auto OFF';
            
            renderAllCards();
        };

        const applyDamage = () => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length < 2) return [];
            
            activePlayers.forEach(p => p.lastDamageTaken = 0);
            const damageTaken = gameState.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
            
            if (activePlayers.length === 2) {
                const [p1, p2] = activePlayers;
                damageTaken[p2.id] += Math.max(0, p1.atk - p2.block);
                damageTaken[p1.id] += Math.max(0, p2.atk - p1.block);
            } else {
                // ‡πÉ‡∏ä‡πâ getOpponents helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å layout ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á 6B
                activePlayers.forEach(attacker => {
                    const opponents = getOpponents(attacker.id, activePlayers);
                    if (opponents.left) damageTaken[opponents.left.id] += Math.max(0, attacker.atk - opponents.left.rightBlock);
                    if (opponents.right) damageTaken[opponents.right.id] += Math.max(0, attacker.atk - opponents.right.leftBlock);
                });
            }

            const newlyDefeatedPlayers = [];
            activePlayers.forEach(p => {
                const finalDamage = Math.max(0, damageTaken[p.id] - p.def);
                if (finalDamage > 0) {
                    p.lastDamageTaken = finalDamage;
                    p.life -= finalDamage;
                    if (p.life <= 0 && !p.isDefeated) newlyDefeatedPlayers.push(p);
                }
            });
            return newlyDefeatedPlayers;
        };
        

        // Minimal simple game over logic and popup
        function checkSimpleGameOver() {
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ú‡∏π‡πâ‡πÅ‡∏û‡πâ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
            gameState.players.forEach(p => { p.isDefeated = false; });
            
            // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° taunt pool ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô
            const availableTaunts = [...(DEFEAT_TAUNTS[gameState.currentLang] || [])];
            const usedTaunts = [];
            
            // Mark all players with life < 1 as defeated ‡πÅ‡∏•‡∏∞‡∏™‡∏∏‡πà‡∏° taunt (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î No taunt)
            const isNoTauntMode = ui.noTauntToggle?.checked || false;
            gameState.players.forEach(p => {
                if (p.life < 1) {
                    p.isDefeated = true;
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ No taunt
                    if (isNoTauntMode) {
                        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "Defeated" ‡πÅ‡∏ó‡∏ô taunt
                        const translations = TRANSLATIONS[gameState.currentLang] || TRANSLATIONS['en'];
                        p.defeatTaunt = translations.defeatedNoTaunt || 'Defeated';
                    } else {
                        // ‡∏™‡∏∏‡πà‡∏° taunt ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô
                        const remainingTaunts = availableTaunts.filter(taunt => !usedTaunts.includes(taunt));
                        if (remainingTaunts.length > 0) {
                            const selectedTaunt = remainingTaunts[Math.floor(Math.random() * remainingTaunts.length)];
                            p.defeatTaunt = selectedTaunt;
                            usedTaunts.push(selectedTaunt);
                        } else {
                            // ‡∏ñ‡πâ‡∏≤ taunt ‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å pool ‡πÄ‡∏î‡∏¥‡∏°
                            p.defeatTaunt = availableTaunts.length ? availableTaunts[Math.floor(Math.random() * availableTaunts.length)] : '';
                        }
                    }
                } else {
                    p.defeatTaunt = null;
                }
            });
            // ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà active ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (previousPlayerState)
            const lastActivePlayers = Array.isArray(gameState.previousPlayerState)
                ? gameState.previousPlayerState.filter(p => !p.isDefeated).map(p => p.id)
                : gameState.players.filter(p => !p.isInitiallyDefeated).map(p => p.id);
            const survivors = gameState.players.filter(p => !p.isDefeated && lastActivePlayers.includes(p.id));
            let winner = null;
            let isDraw = false;
            if (survivors.length === 1) {
                winner = survivors[0];
            } else if (survivors.length === 0) {
                // ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô life < 1 ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà life ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡πÉ‡∏Å‡∏•‡πâ 1 ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î) ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏° lastActivePlayers
                const maxLife = Math.max(...gameState.players.filter(p => lastActivePlayers.includes(p.id)).map(p => p.life));
                const candidates = gameState.players.filter(p => lastActivePlayers.includes(p.id) && p.life === maxLife);
                if (candidates.length === 1) {
                    winner = candidates[0];
                } else {
                    isDraw = true;
                }
            }
            if (winner || isDraw) {
                showSimpleGameOver(winner, isDraw);
                return true;
            }
            return false;
        }

        function showSimpleGameOver(winner, isDraw) {
            const lang = gameState.currentLang;
            let msg = '';
            const modalBox = document.getElementById('simple-gameover-modal-box');
            if (winner) {
                // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤
                const colorName = lang === 'th' ? winner.name : winner.name_en;
                const winnerColor = `<span style="text-shadow:0 2px 8px #000,0 0 2px #fff;font-weight:bold;">${colorName}</span>`;
                msg = `<span style="font-size:2.5rem;display:block;">üèÜ</span>` +
                    `<span style="font-size:2rem;">${TRANSLATIONS[lang].gameOverTitle || 'Game Over!'}</span><br>` +
                    `<span style="font-size:1.5rem;">` +
                    (TRANSLATIONS[lang].winnerMsg ? TRANSLATIONS[lang].winnerMsg(winnerColor) : `Player ${winnerColor} wins!`) +
                    `</span><br><span style="font-size:1.1rem;opacity:0.85;">${lang==='th' ? '‡∏ä‡∏±‡∏¢‡∏ä‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì!' : 'A glorious victory in this war!'}</span>`;
                modalBox.className = `p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full transition-all duration-300 ${winner.tailwindClass} text-white`;
            } else if (isDraw) {
                msg = `<span style="font-size:2.5rem;display:block;">‚öîÔ∏è</span>` +
                    `<span style="font-size:2rem;">${TRANSLATIONS[lang].gameOverTitle || 'Game Over!'}</span><br>` +
                    `<span style="font-size:1.5rem;">${TRANSLATIONS[lang].noWinnerMsg || 'No Winner!'}</span><br>` +
                    `<span style="font-size:1.1rem;opacity:0.85;">${lang==='th' ? '‡∏ó‡∏∏‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡πà‡∏≤‡∏á‡∏•‡πâ‡∏°‡∏•‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏®‡∏±‡∏Å‡∏î‡∏¥‡πå‡∏®‡∏£‡∏µ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏≠‡∏î‡πÉ‡∏ô‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°‡∏ô‡∏µ‡πâ' : 'All have fallen with honor. None remain standing in this war.'}</span>`;
                modalBox.className = 'p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full transition-all duration-300 bg-black text-red-600';
            }
            ui.simpleGameOverMessage.innerHTML = msg;
            ui.simpleGameOverModal.classList.remove('hidden');
            // Show only undo after game over
            ui.nextTurnContainer.classList.remove('hidden');
            ui.undoBtn.disabled = false;
            ui.nextTurnBtn.disabled = true;
            ui.nextTurnBtn.classList.add('hidden');
            gameState.isGameOver = true;
            
            // Clear saved game when game is over
            clearSavedGame();
        }

        const passFirstPlayerToken = () => {
            const order = getTurnOrderHelper();
            
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (order.length === 0 || !gameState.firstPlayerId || activePlayers.length < 2) {
                gameState.firstPlayerId = activePlayers.length > 0 ? activePlayers[0]?.id : null; 
                return;
            };

            const startIndex = order.indexOf(gameState.firstPlayerId);
            if (startIndex === -1) { 
                gameState.firstPlayerId = activePlayers.find(p => order.includes(p.id))?.id || activePlayers[0]?.id;
                return; 
            }

            for (let i = 1; i <= order.length; i++) {
                const nextPlayerId = order[(startIndex + i) % order.length];
                if (activePlayers.some(p => p.id === nextPlayerId)) { 
                    gameState.firstPlayerId = nextPlayerId; 
                    return; 
                }
            }
            gameState.firstPlayerId = activePlayers[0]?.id;
        };


        
        const handleRoundEnd = () => {
            gameState.previousPlayerState = JSON.parse(JSON.stringify(gameState.players));
            const lifeBeforeDamage = gameState.players.map(p => ({ id: p.id, life: p.life, manualLifeChange: p.manualLifeChange }));

            let defeatedBeforeCombat = [];
            const playersAtRoundStart = gameState.players.filter(p => !p.isDefeated);
            playersAtRoundStart.forEach(p => {
                if (p.life <= 0) {
                    defeatedBeforeCombat.push(p);
                }
            });

            logEvent(`<strong>--- Combat Phase ---</strong>`);
            const defeatedInCombat = applyDamage();
            const allNewlyDefeated = [...new Set([...defeatedBeforeCombat, ...defeatedInCombat])];

            gameState.isBuyPhase = true;
            // Clear all auto ready timers when entering buy phase
            gameState.autoReadyTimers.forEach(clearTimeout);
            gameState.autoReadyTimers.clear();
            // Remove all auto ready indicators
            document.querySelectorAll('.auto-ready-indicator').forEach(indicator => indicator.remove());

            playersAtRoundStart.forEach(p => {
                const lifeData = lifeBeforeDamage.find(data => data.id === p.id);
                const manualChangeStr = lifeData.manualLifeChange !== 0 ? ` (${lifeData.manualLifeChange > 0 ? '+' : ''}${lifeData.manualLifeChange})` : '';
                let logStr = `- <span class="${p.textColorClass}">P${p.id}</span> | Life:${lifeData.life}${manualChangeStr} | ATK:${p.atk} DEF:${p.def}`;
                if (playersAtRoundStart.length > 2) {
                    logStr += `, L.Block:${p.leftBlock}, R.Block:${p.rightBlock}`;
                } else {
                    logStr += `, Block:${p.block}`;
                }
                if (p.lastDamageTaken > 0) {
                    logStr += ` | Took: ${p.lastDamageTaken} DMG > New Life: ${p.life}`;
                }
                logEvent(logStr);
            });

            renderAllCards();
            // Check for game over and show popup if needed
            if (!checkSimpleGameOver()) {
                ui.nextTurnContainer.classList.remove('hidden');
                ui.menuContainer.classList.add('hidden'); // Hide menu to prevent overlap
            }
        };

        const startNextTurn = () => {
            if (gameState.isGameOver) return;
            gameState.previousPlayerState = null;
            gameState.isBuyPhase = false;
            ui.nextTurnContainer.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden'); // Show menu again
            passFirstPlayerToken();
            resetPlayerTurnStats();
            gameState.turnCount++;
            ui.turnLogIndicator.textContent = gameState.turnCount;
            if (ui.menuTurnBadge) ui.menuTurnBadge.textContent = String(gameState.turnCount);
            logEvent(`<strong>--- ${TRANSLATIONS[gameState.currentLang].logTurn(gameState.turnCount)} ---</strong>`);
            renderAllCards();
            
            // Auto-save game state after turn
            saveGameState();
            
            // Check for game over and show popup if needed (in case all die in buy phase)
            checkSimpleGameOver();
        };

        const handleUndo = () => {
            if (!gameState.previousPlayerState) return;
            gameState.players = JSON.parse(JSON.stringify(gameState.previousPlayerState));
            gameState.isBuyPhase = false;
            gameState.previousPlayerState = null;
            gameState.isGameOver = false;
            ui.nextTurnBtn.disabled = false;
            ui.nextTurnBtn.classList.remove('hidden');
            ui.nextTurnContainer.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden'); // Show menu again
            // ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏≤‡∏° state ‡∏ó‡∏µ‡πà undo ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ (‡πÑ‡∏°‡πà mark isDefeated ‡πÉ‡∏´‡∏°‡πà)
            renderAllCards();
            
            // Save game state after undo
            saveGameState();
        };


        const performPlayerAction = (playerId, action) => safe(() => {
            if (!validatePlayer(playerId, action)) return;
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;

            // Clear any existing auto ready timer for this player
            clearAutoReady(playerId);

            if (action.includes('life')) {
                const value = action === 'increment-life' ? 1 : -1;
                const oldLife = player.life;
                player.life += value;
                player.manualLifeChange += value;
                showLifeChangeIndicator(player.id, player.manualLifeChange);
                if(gameState.isBuyPhase) logEvent(`- <span class="${player.textColorClass}">P${player.id}</span>'s life changed: ${oldLife} -> ${player.life}.`);
            } else if (action === 'ready') {
                if (gameState.isBuyPhase) return;
                player.isReady = !player.isReady;
                updatePlayerCard(player);
                checkAllReady();
                return;
            } else if (action === 'rotate') {
                // Only allow rotation in first turn
                if (gameState.turnCount === 1 && !gameState.isBuyPhase) {
                    // Add manual rotation to player
                    player.manualRotation = (player.manualRotation || 0) + 90;
                    if (player.manualRotation >= 360) player.manualRotation = 0;
                    updatePlayerCard(player);
                    logEvent(`<span class="${player.textColorClass}">P${player.id}</span> rotated their card by 90¬∞`);
                }
                return;
            } else if (!player.isReady && !gameState.isBuyPhase) {
                const [op, prop] = action.split('-');
                if (['atk', 'def', 'block', 'leftBlock', 'rightBlock'].includes(prop)) {
                    const val = op === 'increment' ? 1 : -1;
                    player[prop] = Math.max(0, player[prop] + val);
                    // Schedule auto ready after ATK/DEF/Block adjustment
                    scheduleAutoReady(playerId);
                }
            }
            updatePlayerCard(player);
            
            // Auto-save after player action (but not on every small change to avoid spam)
            if (gameState.players.length > 0 && gameState.turnCount > 0) {
                // Debounce saves to avoid too frequent saves
                clearTimeout(gameState.saveTimeout);
                gameState.saveTimeout = setTimeout(() => {
                    saveGameState();
                }, 1000);
            }
        });

        const handlePlayerInteraction = (event) => {
            event.preventDefault();
            const touch = event.changedTouches ? event.changedTouches[0] : event;
            const button = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('button[data-action]');
            if (button) performPlayerAction(parseInt(button.dataset.playerId), button.dataset.action);
        };

        const showRandomNumber = () => {
            if (!gameState.initialPlayerCount) return;
            const randomNumber = Math.floor(Math.random() * (gameState.initialPlayerCount + 3)) + 1;
            ui.randomResultBox.textContent = randomNumber;
            ui.randomResultBox.classList.remove('hidden');
            ui.randomResultBox.classList.add('show');
            safeTimeout(() => { ui.randomResultBox.classList.remove('show'); safeTimeout(() => ui.randomResultBox.classList.add('hidden'), 500); }, 1500);
        };



        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å burger menu
        const startDragging = (event) => {
            const touch = event.touches ? event.touches[0] : event;
            const rect = ui.menuContainer.getBoundingClientRect();
            Object.assign(gameState, { isDragging: true, hasMoved: false, dragOffset: { x: touch.clientX - rect.left, y: touch.clientY - rect.top }, 
                startX: touch.clientX, startY: touch.clientY });
            setMenuFaded(false);
            if (gameState.menuFadeTimer) clearTimeout(gameState.menuFadeTimer);
            ui.menuContainer.classList.remove('center-screen');
            Object.assign(ui.menuContainer.style, { bottom: '', right: '', left: rect.left + 'px' });
            ui.menuContainer.style.top = rect.top + 'px';
            ui.menuContainer.style.transform = 'none';

            ui.menuContainer.classList.add('dragging');
        };

        const drag = (event) => {
            if (!gameState.isDragging) return;
            const touch = event.touches ? event.touches[0] : event;
            const [deltaX, deltaY] = [Math.abs(touch.clientX - gameState.startX), Math.abs(touch.clientY - gameState.startY)];
            if (deltaX > CONFIG.DELAYS.DRAG_THRESHOLD || deltaY > CONFIG.DELAYS.DRAG_THRESHOLD) {
                gameState.hasMoved = true;
                event.preventDefault();
            }
            if (gameState.hasMoved) {
                const [x, y] = [touch.clientX - gameState.dragOffset.x, touch.clientY - gameState.dragOffset.y];
                const [maxX, maxY] = [window.innerWidth - ui.menuContainer.offsetWidth, window.innerHeight - ui.menuContainer.offsetHeight];
                
                const clampedX = Math.max(0, Math.min(x, maxX));
                const clampedY = Math.max(0, Math.min(y, maxY));
                
                ui.menuContainer.style.left = clampedX + 'px';
                ui.menuContainer.style.top = clampedY + 'px';
                ui.menuContainer.style.right = 'auto';
                ui.menuContainer.style.transform = 'none';
            }
        };

        const stopDragging = () => {
            if (!gameState.isDragging) return;
            gameState.isDragging = false;
            ui.menuContainer.classList.remove('dragging', 'position-left', 'position-right', 'position-top', 'position-bottom');
            const rect = ui.menuContainer.getBoundingClientRect();
            const [distanceTop, distanceBottom, distanceLeft, distanceRight] = [rect.top, window.innerHeight - rect.bottom, rect.left, window.innerWidth - rect.right];
            const minDistance = Math.min(distanceTop, distanceBottom, distanceLeft, distanceRight);
            
            if (minDistance === distanceTop) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏ö‡∏ô -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
                ui.menuContainer.classList.add('position-bottom');
            } else if (minDistance === distanceBottom) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô  
                ui.menuContainer.classList.add('position-top');
            } else if (minDistance === distanceLeft) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏ã‡πâ‡∏≤‡∏¢ -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤
                ui.menuContainer.classList.add('position-right');
            } else {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏ß‡∏≤ -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
                ui.menuContainer.classList.add('position-left');
            }
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï hasMoved ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏á delay ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö touch events)
            const timeoutId = safeTimeout(() => {
                gameState.hasMoved = false;
                gameState.activeTimeouts.delete(timeoutId);
            }, CONFIG.DELAYS.HASMOVED_RESET, 'resetHasMoved');
            gameState.activeTimeouts.add(timeoutId);

            // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏°‡∏ô‡∏π‡∏à‡∏≤‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏•‡∏≤‡∏Å
            scheduleMenuFade();
        };
        
        const handleFullscreenChange = () => {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                         (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
            
            if (document.fullscreenElement) {
                manageWakeLock(true);
            } else {
                // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ wake lock ‡∏¢‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠
                if (gameState.players.length === 0) {
                    manageWakeLock(false);
                }
            }
            
            // ‡∏•‡∏î resize trigger ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏î‡∏´‡∏î‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô
            if (!isIOS) {
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, CONFIG.DELAYS.RESIZE_DEBOUNCE);
            }
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á burger menu ‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏£‡∏≠‡∏ö
            resetMenuPosition();
            resetMenuFade();
        };
        
        const handleVisibilityChange = () => {
            // ‡πÄ‡∏õ‡∏¥‡∏î wake lock ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡∏Ç‡∏ì‡∏∞‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°‡∏≠‡∏¢‡∏π‡πà
            if (document.visibilityState === 'visible' && gameState.players.length > 0) {
                manageWakeLock(true);
            }
        };

        const setupEventListeners = () => {
            ui.startBtn.addEventListener('click', startGame);

            
            ['mousedown', 'touchstart'].forEach((e, i) => ui.menuBtn.addEventListener(e, startDragging, i ? { passive: true } : undefined));
            ['mousemove', 'touchmove'].forEach((e, i) => document.addEventListener(e, drag, i ? { passive: false } : undefined));
            ['mouseup', 'touchend'].forEach(e => document.addEventListener(e, stopDragging));
            ui.closeLogBtn.addEventListener('click', () => ui.logModal.classList.add('hidden'));
            ui.openLogBtn.addEventListener('click', () => { updateLogModal(); ui.logModal.classList.remove('hidden'); ui.menuDropdown.classList.remove('active'); });
            ['touchstart', 'click'].forEach((e, i) => ui.playersContainer.addEventListener(e, handlePlayerInteraction, i ? { passive: false } : undefined));
            // Handle click/tap for opening menu
            const handleMenuClick = (event) => {
                // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î menu ‡∏´‡∏≤‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏•‡∏≤‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à
                if (!gameState.hasMoved && !gameState.isDragging) {
                    ui.menuDropdown.classList.toggle('active');
                    resetMenuFade();
                }
            };
            
            ui.menuBtn.addEventListener('click', handleMenuClick);
            ui.menuBtn.addEventListener('touchend', (event) => {
                if (!gameState.hasMoved && !gameState.isDragging) {
                    event.preventDefault();
                    handleMenuClick(event);
                }
            });
            ui.restartGameBtn.addEventListener('click', () => ui.confirmModal.classList.remove('hidden'));
            ui.randomBtn.addEventListener('click', showRandomNumber);
            
            // Instructions modal event listeners
            ui.instructionsLink.addEventListener('click', () => {
                updateInstructionsContent();
                ui.instructionsModal.classList.remove('hidden');
            });
            ui.menuInstructionsBtn.addEventListener('click', () => {
                updateInstructionsContent();
                ui.instructionsModal.classList.remove('hidden');
                ui.menuDropdown.classList.remove('active');
            });
            ui.closeInstructionsBtn.addEventListener('click', () => {
                ui.instructionsModal.classList.add('hidden');
            });
            
            // Toggle countdown functionality
            ui.toggleCountdownBtn.addEventListener('click', () => {
                gameState.countdownEnabled = !gameState.countdownEnabled;
                ui.toggleCountdownBtn.textContent = gameState.countdownEnabled ? '‚è±Ô∏è Auto ON' : '‚è±Ô∏è Auto OFF';
                ui.menuDropdown.classList.remove('active');
            });
            ui.nextTurnBtn.addEventListener('click', startNextTurn);
            ui.undoBtn.addEventListener('click', handleUndo);
            ui.toggleFullscreenBtn.addEventListener('click', () => {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                             (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
                
                if (!document.fullscreenElement) {
                    let o = 'landscape';
                    if ([2, 3, 4, 7, 8].includes(gameState.initialPlayerCount) || ['6B', '6C', '5B', '5C', '3B'].includes(gameState.layoutMode)) {
                        o = 'portrait-primary';
                    }
                    
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡πÄ‡∏®‡∏©‡πÅ‡∏ó‡∏ô fullscreen API
                    if (isIOS) {
                        // ‡πÉ‡∏ä‡πâ CSS ‡πÅ‡∏•‡∏∞ viewport manipulation ‡πÅ‡∏ó‡∏ô
                        document.body.style.position = 'fixed';
                        document.body.style.top = '0';
                        document.body.style.left = '0';
                        document.body.style.width = '100%';
                        document.body.style.height = '100vh';
                        document.body.style.height = '100dvh';
                    } else {
                        goFullscreen(o);
                    }
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (isIOS) {
                    // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ CSS ‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS
                    document.body.style.position = 'fixed';
                }

            });
            ui.languageSelector.addEventListener('change', (event) => setLanguage(event.target.value));
            ui.playerCountSelector.addEventListener('change', () => {
                updateColorSelectOnPlayerCountChange();
            });
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('visibilitychange', handleVisibilityChange);
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏≠ (‡∏î‡∏µ‡πÄ‡∏•‡∏¢‡πå‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ layout ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£)
            let orientationTimeout;
            window.addEventListener('orientationchange', () => {
                if (orientationTimeout) clearTimeout(orientationTimeout);
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° delay ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏î‡∏´‡∏î‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô
                const delay = isIOS ? 500 : CONFIG.DELAYS.ORIENTATION_CHANGE;
                
                orientationTimeout = setTimeout(() => {
                    resetMenuPosition();
                    // ‡πÉ‡∏ô iOS ‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£ dispatch resize event ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
                    if (!isIOS && gameState.players.length > 0) {
                        window.dispatchEvent(new Event('resize'));
                    }
                }, delay);
            });

            ui.confirmCancelBtn.addEventListener('click', () => ui.confirmModal.classList.add('hidden'));
            ui.confirmOkBtn.addEventListener('click', () => {
                ui.confirmModal.classList.add('hidden');
                setTimeout(resetGame, 50);
            });

            const closeMenuHandler = (event) => {
                if (ui.menuDropdown.classList.contains('active') && !ui.menuContainer.contains(event.target)) {
                    ui.menuDropdown.classList.remove('active');
                }
            };
            document.addEventListener('click', closeMenuHandler);
            document.addEventListener('touchstart', closeMenuHandler);

            ui.menuDropdown.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    ui.menuDropdown.classList.remove('active');
                    resetMenuFade();
                }
            });

            // Global interactions reset fade timer
            ['mousemove','touchstart','keydown'].forEach(ev => {
                document.addEventListener(ev, () => resetMenuFade(), { passive: true });
            });
            ui.menuContainer.addEventListener('mouseenter', () => resetMenuFade());
            ui.menuContainer.addEventListener('mouseleave', () => scheduleMenuFade());
        };
        
        document.addEventListener('DOMContentLoaded', async () => {

            setLanguage(gameState.currentLang);
            renderColorSelectPanel();
            setupEventListeners();
            
            // Check for saved game and show restore dialog
            const savedGameData = loadGameState();
            
            if (savedGameData && savedGameData.players && savedGameData.players.length > 0) {
                try {
                    const shouldRestore = await showRestoreConfirmDialog(savedGameData);
                    
                    if (shouldRestore) {
                        restoreGameState(savedGameData);
                    } else {
                        clearSavedGame();
                    }
                } catch (error) {
                    console.error('Error in restore dialog:', error);
                }
            }
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏° listeners ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sync content area ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
            // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô resize event ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡πÉ‡∏ô iOS
            let resizeTimeout;
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                         (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
            
            window.addEventListener('resize', () => {
                if (resizeTimeout) clearTimeout(resizeTimeout);
                
                const delay = isIOS ? 300 : 100; // ‡πÄ‡∏û‡∏¥‡πà‡∏° delay ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iOS
                
                resizeTimeout = setTimeout(() => {
                    if (gameState.players && gameState.players.length > 0) {
                        gameState.players.forEach(player => {
                            const card = document.getElementById(`player-card-${player.id}`);
                            if (card) syncContentAreaWithCardBackground(card);
                        });
                    }
                }, delay);
            });
            
            // Simple game over modal close button
            ui.simpleGameOverClose.addEventListener('click', () => {
                ui.simpleGameOverModal.classList.add('hidden');
                resetGame();
            });
            // Allow closing modal by clicking outside the box
            ui.simpleGameOverModal.addEventListener('click', (e) => {
                if (e.target === ui.simpleGameOverModal) {
                    ui.simpleGameOverModal.classList.add('hidden');
                }
            });
        });
    </script>
</body>
</html>
