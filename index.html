<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="title">Crayne Influence Counter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            height: 100vh;
            overflow: hidden;
        }
        .defeated-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(40, 10, 10, 0.6);
            color: #ff8a8a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 1rem;
            backdrop-filter: blur(1px);
            -webkit-backdrop-filter: blur(1px);
        }
        .setup-image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            max-width: 80%;
            height: auto;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin-left: auto;
            margin-right: auto;
        }
        .setup-image { width: 100%; height: auto; display: block; }
        #menu-container { position: fixed; top: 50%; right: 1rem; transform: translateY(-50%); z-index: 50; }
        #menu-btn {
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 9999px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        #menu-btn:hover { transform: scale(1.05); }
        #menu-dropdown {
            position: absolute; bottom: 50%; right: 100%;
            transform: translateY(50%);
            width: 150px;
            margin-right: 0.75rem;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            opacity: 0;
            transform-origin: right center;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
        }
        #menu-dropdown.active { opacity: 1; transform: translateY(50%) scale(1); pointer-events: auto; }
        #menu-dropdown button { width: 100%; text-align: left; padding: 0.75rem 1rem; transition: background-color 0.2s; }
        #menu-dropdown button:hover { background-color: rgba(0, 0, 0, 0.05); }
        #random-result-box {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            padding: 2rem 4rem;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 2rem;
            font-size: 8rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #random-result-box.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .first-player-highlight {
            color: #FFD700;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 0 12px #FFD700;
        }
        .damage-indicator {
            position: absolute; 
            bottom: -1em;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 700;
            pointer-events: none;
            opacity: 0.5;
        }
        .damage-indicator-red { color: #fca5a5; }
        .damage-indicator-purple { color: #f9a8d4; }
        .damage-indicator-normal { color: #ef4444; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center h-screen p-2">

    <!-- Game setup controls -->
    <div id="setup-controls" class="bg-white p-4 rounded-2xl shadow-xl w-full max-w-4xl mx-auto text-center mb-2 flex-shrink-0">
        <div class="flex justify-end mb-2">
            <select id="language-selector" class="p-1 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200 text-sm">
                <option value="th">ไทย</option>
                <option value="en" selected>English</option>
            </select>
        </div>
        <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-2" data-lang-key="appTitle"></h1>
        <div class="setup-image-container">
            <img src="CrayneLogo.jpg" alt="Crayne Fractured Empire Logo" class="setup-image">
        </div>
        <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4">
            <div class="flex items-center space-x-2 w-full sm:w-auto">
                <label for="player-count" class="text-md sm:text-lg font-semibold text-gray-700" data-lang-key="playerCountLabel"></label>
                <select id="player-count" class="p-1 sm:p-2 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200">
                    <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option>
                </select>
            </div>
            <button id="start-btn" class="w-full sm:w-auto py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="startButton"></button>
        </div>
    </div>
    
    <!-- Player cards container -->
    <div id="players-container" class="w-full max-w-4xl mx-auto flex-grow grid grid-cols-1 sm:grid-cols-2 gap-1 sm:gap-2 p-2 min-h-0"></div>

    <!-- Floating Menu Container -->
    <div id="menu-container" class="hidden">
        <button id="menu-btn" class="text-gray-600">
            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
        </button>
        <div id="menu-dropdown" class="text-gray-800">
            <button id="restart-game-btn" data-lang-key="menuRestart"></button>
            <button id="fullscreen-menu-btn" data-lang-key="menuFullscreen"></button>
            <button id="random-btn" data-lang-key="menuRandom"></button>
        </div>
    </div>

    <!-- Random Number Display -->
    <div id="random-result-box" class="hidden"></div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 cursor-pointer">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full transform scale-100 transition-transform duration-300 cursor-default">
            <h2 class="text-4xl font-extrabold text-red-500 mb-4" data-lang-key="gameOverTitle"></h2>
            <p id="winner-message" class="text-xl font-bold text-gray-700 mb-6"></p>
            <button id="modal-reset-btn" class="py-3 px-6 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="newGameButton"></button>
        </div>
    </div>

    <p id="version-display" class="fixed bottom-2 right-3 text-xs text-gray-400 select-none z-10">v2.0.2</p>

    <script>
        // --- Constants ---
        const STARTING_LIFE = { 2: 30, default: 60 };
        const CUSTOM_ORDERS = { 2: [1, 2], 3: [1, 2, 3], 4: [1, 2, 4, 3], 5: [1, 2, 3, 5, 4], 6: [1, 2, 3, 6, 5, 4] };
        const PLAYER_COLORS = [
            { name: 'แดง', name_en: 'Red', tailwindClass: 'bg-red-500', textColorClass: 'text-red-500' }, 
            { name: 'น้ำเงิน', name_en: 'Blue', tailwindClass: 'bg-blue-500', textColorClass: 'text-blue-500' },
            { name: 'เขียว', name_en: 'Green', tailwindClass: 'bg-green-500', textColorClass: 'text-green-500' },
            { name: 'เหลือง', name_en: 'Yellow', tailwindClass: 'bg-yellow-500', textColorClass: 'text-yellow-500' },
            { name: 'ม่วง', name_en: 'Purple', tailwindClass: 'bg-purple-500', textColorClass: 'text-purple-500' },
            { name: 'ฟ้า', name_en: 'Cyan', tailwindClass: 'bg-cyan-500', textColorClass: 'text-cyan-500' }
        ];
        const TRANSLATIONS = {
            'th': { title: 'เครื่องนับ Influence Crayne', appTitle: 'เครื่องนับ Influence Crayne', playerCountLabel: 'จำนวนผู้เล่น:', startButton: 'เริ่มเกม', gameOverTitle: 'เกมจบแล้ว!', newGameButton: 'เริ่มเกมใหม่', ready: 'พร้อม', defeated: 'แพ้แล้ว', block: 'บล็อก', winnerMsg: (c) => `ผู้เล่น ${c} เป็นผู้ชนะ!`, noWinnerMsg: 'ผู้เล่นทั้งหมดแพ้แล้ว!', menuRestart: 'รีสตาร์ท', menuFullscreen: 'ขยายเต็มจอ', menuRandom: 'สุ่มเลข' },
            'en': { title: 'Crayne Influence Counter', appTitle: 'Crayne Influence Counter', playerCountLabel: 'Players:', startButton: 'Start Game', gameOverTitle: 'Game Over!', newGameButton: 'New Game', ready: 'Ready', defeated: 'Defeated', block: 'Block', winnerMsg: (c) => `Player ${c} wins!`, noWinnerMsg: 'All players have been defeated!', menuRestart: 'Restart', menuFullscreen: 'Fullscreen', menuRandom: 'Random' }
        };

        // --- Game State ---
        const gameState = {
            players: [],
            initialPlayerCount: 0,
            firstPlayerId: null,
            currentLang: localStorage.getItem('appLang') || 'th'
        };

        // --- DOM Elements ---
        const ui = {
            playerCountSelector: document.getElementById('player-count'),
            playersContainer: document.getElementById('players-container'),
            startBtn: document.getElementById('start-btn'),
            setupControls: document.getElementById('setup-controls'),
            gameOverModal: document.getElementById('game-over-modal'),
            winnerMessage: document.getElementById('winner-message'),
            modalResetBtn: document.getElementById('modal-reset-btn'),
            languageSelector: document.getElementById('language-selector'),
            menuContainer: document.getElementById('menu-container'),
            menuBtn: document.getElementById('menu-btn'),
            menuDropdown: document.getElementById('menu-dropdown'),
            restartGameBtn: document.getElementById('restart-game-btn'),
            fullscreenMenuBtn: document.getElementById('fullscreen-menu-btn'),
            randomBtn: document.getElementById('random-btn'),
            randomResultBox: document.getElementById('random-result-box'),
            versionDisplay: document.getElementById('version-display')
        };

        // --- UI Rendering ---

        /** Creates HTML for a player's block controls. */
        const createBlockControlsHTML = (player, fontSizes, leftColor, rightColor) => {
            const t = (key) => TRANSLATIONS[gameState.currentLang][key];
            const activePlayersCount = gameState.players.filter(p => !p.isDefeated).length;

            // **BUG FIX**: If only 2 players remain in a 3-6 player game, switch to single block mode.
            if (gameState.initialPlayerCount > 2 && activePlayersCount === 2) {
                return `<div class="flex-1"></div><div class="flex flex-col items-center flex-1 min-w-0"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="block-display ${fontSizes.block}">${player.block}</span><button data-player-id="${player.id}" data-action="increment-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex-1 flex justify-center"><button data-player-id="${player.id}" data-action="ready" class="ready-btn ${fontSizes.readyBtn} bg-white text-gray-800 font-semibold rounded-xl shadow-lg active:shadow-none active:translate-y-1 transform">${t('ready')}</button></div>`;
            }
            
            if (gameState.initialPlayerCount === 2) {
                return `<div class="flex-1"></div><div class="flex flex-col items-center flex-1 min-w-0"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="block-display ${fontSizes.block}">${player.block}</span><button data-player-id="${player.id}" data-action="increment-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex-1 flex justify-center"><button data-player-id="${player.id}" data-action="ready" class="ready-btn ${fontSizes.readyBtn} bg-white text-gray-800 font-semibold rounded-xl shadow-lg active:shadow-none active:translate-y-1 transform">${t('ready')}</button></div>`;
            }
            return `<div class="flex flex-col items-center flex-1 min-w-0"><div class="flex items-center space-x-1 justify-center"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="w-3 h-3 sm:w-4 sm:h-4 rounded-full ${leftColor} ring-2 ring-white"></div></div><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="left-block-display ${fontSizes.block}">${player.leftBlock}</span><button data-player-id="${player.id}" data-action="increment-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex-shrink-0"><button data-player-id="${player.id}" data-action="ready" class="ready-btn ${fontSizes.readyBtn} bg-white text-gray-800 font-semibold rounded-xl shadow-lg active:shadow-none active:translate-y-1 transform">${t('ready')}</button></div><div class="flex flex-col items-center flex-1 min-w-0"><div class="flex items-center space-x-1 justify-center"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="w-3 h-3 sm:w-4 sm:h-4 rounded-full ${rightColor} ring-2 ring-white" ></div></div><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="right-block-display ${fontSizes.block}">${player.rightBlock}</span><button data-player-id="${player.id}" data-action="increment-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div>`;
        };
        
        /** Creates HTML for a player's ATK/DEF controls. */
        const createStatControlsHTML = (player, fontSizes) => {
            return `<div class="flex flex-col items-center flex-1 min-w-0"><span class="${fontSizes.label} font-semibold">ATK</span><div class="flex items-center space-x-0.5"><button data-player-id="${player.id}" data-action="decrement-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="atk-display ${fontSizes.stats}">${player.atk}</span><button data-player-id="${player.id}" data-action="increment-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex flex-col items-center flex-1 min-w-0"><span class="${fontSizes.label} font-semibold">DEF</span><div class="flex items-center space-x-0.5"><button data-player-id="${player.id}" data-action="decrement-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="def-display ${fontSizes.stats}">${player.def}</span><button data-player-id="${player.id}" data-action="increment-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div>`;
        };

        /** Creates a single player card UI element. */
        const createPlayerCard = (player) => {
            const playerCard = document.createElement('div');
            playerCard.id = `player-card-${player.id}`;
            playerCard.className = `${player.tailwindClass} text-white rounded-2xl shadow-xl transform transition-all duration-300 relative overflow-hidden flex-1 flex flex-col justify-between`;
            
            if (player.isDefeated) playerCard.classList.add('opacity-40');
            if (gameState.initialPlayerCount === 2 ? player.id === 1 : player.id <= Math.ceil(gameState.initialPlayerCount / 2)) {
                playerCard.classList.add('rotate-180');
            }

            const activePlayerOrder = (CUSTOM_ORDERS[gameState.initialPlayerCount] || []).filter(id => gameState.players.find(p => p.id === id && !p.isDefeated));
            const currentPlayerIndex = activePlayerOrder.indexOf(player.id);
            let leftOpponentColorClass = 'bg-white', rightOpponentColorClass = 'bg-white';
            if (activePlayerOrder.length > 1 && currentPlayerIndex !== -1) {
                const leftOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex + 1) % activePlayerOrder.length]);
                const rightOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                if (leftOpponent) leftOpponentColorClass = leftOpponent.tailwindClass;
                if (rightOpponent) rightOpponentColorClass = rightOpponent.tailwindClass;
            }

            const isFirstPlayer = player.id === gameState.firstPlayerId && !player.isDefeated;
            const t = (key) => TRANSLATIONS[gameState.currentLang][key];
            const isTwoPlayerMode = gameState.initialPlayerCount === 2;
            const fontSizes = {
                life: isTwoPlayerMode ? 'text-8xl' : 'text-xl sm:text-2xl md:text-3xl lg:text-4xl',
                stats: isTwoPlayerMode ? 'text-6xl font-bold' : 'text-2xl sm:text-3xl md:text-4xl font-bold',
                block: isTwoPlayerMode ? 'text-4xl font-bold' : 'text-xl sm:text-2xl font-bold',
                label: isTwoPlayerMode ? 'text-lg' : 'text-xs',
                readyBtn: isTwoPlayerMode ? 'p-3 text-lg' : 'p-2 text-sm',
                smallBtn: isTwoPlayerMode ? 'w-8 h-8' : 'w-4 h-4 sm:w-5 sm:h-5',
                mediumBtn: isTwoPlayerMode ? 'w-10 h-10' : 'w-5 h-5 sm:w-6 sm:h-6',
                largeBtn: isTwoPlayerMode ? 'w-12 h-12 text-3xl' : 'w-7 h-7 sm:w-9 sm:h-9 text-lg sm:text-xl',
                damage: isTwoPlayerMode ? 'text-4xl' : 'text-2xl'
            };
            let damageIndicatorColor = player.tailwindClass.includes('red') ? 'damage-indicator-red' : player.tailwindClass.includes('purple') ? 'damage-indicator-purple' : 'damage-indicator-normal';
            
            playerCard.innerHTML = `
                <div class="card-content p-1 sm:p-2 flex flex-col items-center justify-between flex-grow">
                    <div class="flex items-center justify-between w-full flex-shrink-0 flex-wrap space-x-1 text-white">${createBlockControlsHTML(player, fontSizes, leftOpponentColorClass, rightOpponentColorClass)}</div>
                    <div class="flex-grow flex items-center justify-center">
                        <div class="flex items-center justify-center space-x-1 my-2 flex-shrink-0">
                            <button data-player-id="${player.id}" data-action="decrement-life" class="${fontSizes.largeBtn} bg-black bg-opacity-30 hover:bg-opacity-50 rounded-full shadow-lg active:shadow-none active:translate-y-1 transform">-</button>
                            <div class="relative">
                                <div class="life-display ${fontSizes.life} font-extrabold transition-all duration-300 ${isFirstPlayer ? 'first-player-highlight' : ''}">${player.life}</div>
                                ${player.lastDamageTaken > 0 ? `<span class="damage-indicator ${damageIndicatorColor} ${fontSizes.damage}">-${player.lastDamageTaken}</span>` : ''}
                            </div>
                            <button data-player-id="${player.id}" data-action="increment-life" class="${fontSizes.largeBtn} bg-black bg-opacity-30 hover:bg-opacity-50 rounded-full shadow-lg active:shadow-none active:translate-y-1 transform">+</button>
                        </div>
                    </div>
                    <div class="flex justify-center items-center space-x-2 w-full flex-shrink-0 mt-auto text-white">${createStatControlsHTML(player, fontSizes)}</div>
                </div>
                ${player.isDefeated ? `<div class="defeated-overlay"><span class="text-2xl font-extrabold">${t('defeated')}</span></div>` : ''}
            `;
            updateDynamicCardElements(player, playerCard);
            return playerCard;
        };

        /** Renders all player cards based on the current game state. */
        const renderPlayers = () => {
            ui.playersContainer.innerHTML = '';
            if (gameState.initialPlayerCount === 0) return;

            if (gameState.initialPlayerCount === 2) {
                ui.playersContainer.className = 'w-full max-w-md mx-auto flex-grow flex flex-col gap-1 sm:gap-2 p-2 min-h-0';
                gameState.players.forEach(player => ui.playersContainer.appendChild(createPlayerCard(player)));
            } else {
                let gridClass = 'grid-cols-2';
                if (gameState.initialPlayerCount === 3) gridClass = 'grid-cols-2 sm:grid-cols-2';
                if (gameState.initialPlayerCount === 5 || gameState.initialPlayerCount === 6) gridClass = 'grid-cols-2 md:grid-cols-3';
                ui.playersContainer.className = `w-full max-w-4xl mx-auto flex-grow grid gap-1 sm:gap-2 p-2 min-h-0 ${gridClass}`;
                
                gameState.players.forEach((player) => {
                    const playerCard = createPlayerCard(player);
                    if (gameState.initialPlayerCount === 3 && player.id === 3) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'col-span-full flex justify-center';
                        wrapper.appendChild(playerCard);
                        ui.playersContainer.appendChild(wrapper);
                    } else {
                        ui.playersContainer.appendChild(playerCard);
                    }
                });
                if (gameState.initialPlayerCount === 5) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'hidden md:block md:col-start-1';
                    ui.playersContainer.insertBefore(placeholder, ui.playersContainer.children[3]);
                }
            }
        };

        /** Updates dynamic elements of a player card (e.g., button state). */
        const updateDynamicCardElements = (player, playerCard) => {
            const readyBtn = playerCard.querySelector(`.ready-btn`);
            if (!readyBtn) return;
            readyBtn.textContent = TRANSLATIONS[gameState.currentLang].ready;
            readyBtn.classList.toggle('bg-green-500', player.isReady);
            readyBtn.classList.toggle('hover:bg-green-600', player.isReady);
            readyBtn.classList.toggle('text-white', player.isReady);
            readyBtn.classList.toggle('bg-white', !player.isReady);
            readyBtn.classList.toggle('text-gray-800', !player.isReady);
            const shouldLockControls = player.isDefeated || player.isReady;
            playerCard.querySelectorAll(`[data-action$="-atk"], [data-action$="-def"], [data-action*="Block"]`).forEach(btn => btn.disabled = shouldLockControls);
            playerCard.querySelectorAll(`[data-action$="-life"]`).forEach(btn => btn.disabled = player.isDefeated);
            readyBtn.disabled = player.isDefeated;
        };
        
        /** Updates only the stat numbers on a player card to avoid a full re-render. */
        const updatePlayerStatDisplay = (player) => {
            const card = document.getElementById(`player-card-${player.id}`);
            if (!card) return;
            card.querySelector('.life-display').textContent = player.life;
            card.querySelector('.atk-display').textContent = player.atk;
            card.querySelector('.def-display').textContent = player.def;

            const activePlayersCount = gameState.players.filter(p => !p.isDefeated).length;
            if (gameState.initialPlayerCount > 2 && activePlayersCount === 2) {
                 const blockDisplay = card.querySelector('.block-display');
                 if(blockDisplay) blockDisplay.textContent = player.block;
            } else if (gameState.initialPlayerCount === 2) {
                 card.querySelector('.block-display').textContent = player.block;
            } else {
                card.querySelector('.left-block-display').textContent = player.leftBlock;
                card.querySelector('.right-block-display').textContent = player.rightBlock;
            }
        };

        /** Sets the application language and updates the UI. */
        const setLanguage = (lang) => {
            gameState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (TRANSLATIONS[lang][key]) {
                    el.textContent = TRANSLATIONS[lang][key];
                }
            });
            if (gameState.players.length > 0) renderPlayers();
        };

        // --- Game Logic ---

        /** Initializes players for a new game. */
        const initPlayers = () => {
            const startingLife = STARTING_LIFE[gameState.initialPlayerCount] || STARTING_LIFE.default;
            gameState.players = Array.from({ length: gameState.initialPlayerCount }, (_, i) => ({
                id: i + 1, ...PLAYER_COLORS[i], life: startingLife,
                atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0,
                isReady: false, isDefeated: false, lastDamageTaken: 0
            }));
            if (gameState.players.length > 0) {
                gameState.firstPlayerId = gameState.players[Math.floor(Math.random() * gameState.players.length)].id;
            }
            renderPlayers();
        };

        /** Starts the game. */
        const startGame = () => {
            gameState.initialPlayerCount = parseInt(ui.playerCountSelector.value);
            const orientation = gameState.initialPlayerCount === 2 ? 'portrait-primary' : 'landscape';
            goFullscreen(orientation);
            initPlayers();
            ui.setupControls.classList.add('hidden');
            ui.gameOverModal.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden');
            ui.versionDisplay.classList.add('hidden');
        };

        /** Resets the game to the setup screen. */
        const resetGame = () => {
            Object.assign(gameState, { players: [], initialPlayerCount: 0, firstPlayerId: null });
            ui.playersContainer.innerHTML = '';
            ui.setupControls.classList.remove('hidden');
            ui.gameOverModal.classList.add('hidden');
            ui.menuContainer.classList.add('hidden');
            ui.menuDropdown.classList.remove('active');
            ui.versionDisplay.classList.remove('hidden');
            if (document.fullscreenElement) document.exitFullscreen();
            setLanguage(gameState.currentLang);
        };
        
        /** Applies damage to all players based on ATK and BLOCK/DEF values. */
        const applyDamage = () => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length < 2) return [];

            activePlayers.forEach(p => p.lastDamageTaken = 0);
            const damageTaken = gameState.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});

            // **BUG FIX**: If only 2 players remain, use single block logic.
            if (activePlayers.length === 2) {
                const [p1, p2] = activePlayers;
                damageTaken[p2.id] += Math.max(0, p1.atk - p2.block);
                damageTaken[p1.id] += Math.max(0, p2.atk - p1.block);
            } else {
                const activePlayerOrder = CUSTOM_ORDERS[gameState.initialPlayerCount].filter(id => activePlayers.some(p => p.id === id));
                activePlayerOrder.forEach((attackerId, index) => {
                    const attacker = gameState.players.find(p => p.id === attackerId);
                    const leftDefender = gameState.players.find(p => p.id === activePlayerOrder[(index + 1) % activePlayerOrder.length]);
                    const rightDefender = gameState.players.find(p => p.id === activePlayerOrder[(index - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                    if (leftDefender) damageTaken[leftDefender.id] += Math.max(0, attacker.atk - leftDefender.rightBlock);
                    if (rightDefender) damageTaken[rightDefender.id] += Math.max(0, attacker.atk - rightDefender.leftBlock);
                });
            }

            const newlyDefeatedPlayers = [];
            activePlayers.forEach(p => {
                const finalDamage = Math.max(0, damageTaken[p.id] - p.def);
                if (finalDamage > 0) {
                    p.lastDamageTaken = finalDamage;
                    p.life -= finalDamage;
                    if (p.life <= 0) {
                        p.isDefeated = true;
                        newlyDefeatedPlayers.push(p);
                    }
                }
            });
            return newlyDefeatedPlayers;
        };

        /** Checks for a game over condition and displays the modal if necessary. */
        const checkGameOver = (newlyDefeatedPlayers) => {
            const remainingPlayers = gameState.players.filter(p => !p.isDefeated);
            let winner = null;
            let isGameOver = false;

            if (remainingPlayers.length === 1) {
                winner = remainingPlayers[0];
                isGameOver = true;
            } else if (remainingPlayers.length === 0) {
                isGameOver = true;
                if (newlyDefeatedPlayers.length > 1) {
                    newlyDefeatedPlayers.sort((a, b) => b.life - a.life);
                    if (newlyDefeatedPlayers[0].life > newlyDefeatedPlayers[1].life) {
                        winner = newlyDefeatedPlayers[0];
                    }
                }
            }
            
            if (isGameOver) {
                setTimeout(() => {
                    const t = (key, arg) => TRANSLATIONS[gameState.currentLang][key](arg);
                    if (winner) {
                        ui.winnerMessage.textContent = t('winnerMsg', gameState.currentLang === 'en' ? winner.name_en : winner.name);
                        ui.winnerMessage.className = `text-xl font-bold ${winner.textColorClass} mb-6`;
                    } else {
                        ui.winnerMessage.textContent = t('noWinnerMsg');
                        ui.winnerMessage.className = `text-xl font-bold text-gray-700 mb-6`;
                    }
                    ui.gameOverModal.classList.remove('hidden');
                }, 2000);
            }
        };

        /** Passes the first player token to the next active player. */
        const passFirstPlayerToken = () => {
            const fullOrder = CUSTOM_ORDERS[gameState.initialPlayerCount] || [];
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (fullOrder.length === 0 || !gameState.firstPlayerId || activePlayers.length < 2) {
                gameState.firstPlayerId = activePlayers.length > 0 ? activePlayers[0]?.id : null;
                return;
            };
            const startIndex = fullOrder.indexOf(gameState.firstPlayerId);
            if (startIndex === -1) {
                gameState.firstPlayerId = activePlayers[0]?.id;
                return;
            }
            for (let i = 1; i <= fullOrder.length; i++) {
                const nextPlayerId = fullOrder[(startIndex + i) % fullOrder.length];
                if (activePlayers.some(p => p.id === nextPlayerId)) {
                    gameState.firstPlayerId = nextPlayerId;
                    return;
                }
            }
            gameState.firstPlayerId = activePlayers[0]?.id;
        };

        /** Resets player stats for the new turn. */
        const resetPlayerTurnStats = () => {
            gameState.players.forEach(p => {
                if (!p.isDefeated) {
                    Object.assign(p, { atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false });
                }
            });
        };

        /** Main function to handle the end of a round. */
        const handleRoundEnd = () => {
            const newlyDefeatedPlayers = applyDamage();
            passFirstPlayerToken();
            resetPlayerTurnStats();
            renderPlayers();
            checkGameOver(newlyDefeatedPlayers);
        };
        
        /** Checks if all active players are ready to proceed to the next round. */
        const checkAllReady = () => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length > 0 && activePlayers.every(p => p.isReady)) {
                handleRoundEnd();
            }
        };

        /** Enters fullscreen mode. */
        const goFullscreen = (orientation = 'landscape') => {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock(orientation).catch(() => {});
            }
        };

        /** Generates and displays a random number. */
        const generateRandomNumber = () => {
            if (gameState.initialPlayerCount === 0) return;
            const randomNumber = Math.floor(Math.random() * (gameState.initialPlayerCount + 2)) + 1;
            ui.randomResultBox.textContent = randomNumber;
            ui.randomResultBox.classList.remove('hidden');
            setTimeout(() => ui.randomResultBox.classList.add('show'), 10);
            setTimeout(() => {
                ui.randomResultBox.classList.remove('show');
                setTimeout(() => ui.randomResultBox.classList.add('hidden'), 500);
            }, 3000);
        };

        // --- Event Handlers ---

        /** Handles all click events on the player cards. */
        const handlePlayerEvent = (event) => {
            const button = event.target.closest('button');
            if (!button) return;

            const playerId = parseInt(button.dataset.playerId);
            const action = button.dataset.action;
            const player = gameState.players.find(p => p.id === playerId);

            if (!player || player.isDefeated) return;
            if (player.isReady && !['ready', 'increment-life', 'decrement-life'].includes(action)) return;

            if (action === 'ready') {
                player.isReady = !player.isReady;
                updateDynamicCardElements(player, button.closest(`#player-card-${player.id}`));
                checkAllReady();
                return;
            }

            const [operation, property] = action.split('-');
            if (property in player) {
                const value = operation === 'increment' ? 1 : -1;
                player[property] += value;
                if (!property.toLowerCase().includes('life')) {
                    player[property] = Math.max(0, player[property]);
                }
            }
            updatePlayerStatDisplay(player);
        };
        
        // --- Initialization ---
        
        /** Binds all initial event listeners. */
        const bindEventListeners = () => {
            ui.startBtn.addEventListener('click', startGame);
            ui.modalResetBtn.addEventListener('click', resetGame);
            ui.playersContainer.addEventListener('click', handlePlayerEvent);
            ui.menuBtn.addEventListener('click', () => ui.menuDropdown.classList.toggle('active'));
            ui.restartGameBtn.addEventListener('click', resetGame);
            ui.fullscreenMenuBtn.addEventListener('click', () => {
                goFullscreen(gameState.initialPlayerCount === 2 ? 'portrait-primary' : 'landscape');
                ui.menuDropdown.classList.remove('active');
            });
            ui.randomBtn.addEventListener('click', () => {
                generateRandomNumber();
                ui.menuDropdown.classList.remove('active');
            });
            ui.languageSelector.addEventListener('change', (event) => setLanguage(event.target.value));
            ui.gameOverModal.addEventListener('click', (event) => {
                if (event.target === ui.gameOverModal) ui.gameOverModal.classList.add('hidden');
            });
        };

        /** Initial setup on page load. */
        document.addEventListener('DOMContentLoaded', () => {
            ui.languageSelector.value = gameState.currentLang;
            setLanguage(gameState.currentLang);
            bindEventListeners();
        });
    </script>
</body>
</html>
