<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="title">Crayne Influence Counter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            height: 100vh;
            overflow: hidden;
            /* Disable user selection to prevent annoying text highlighting on multi-touch */
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .defeated-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(40, 10, 10, 0.6);
            color: #ff8a8a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(1px);
            -webkit-backdrop-filter: blur(1px);
            padding: 1rem;
            text-align: center;
        }
        .setup-image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            max-width: 80%;
            height: auto;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin-left: auto;
            margin-right: auto;
        }
        .setup-image { width: 100%; height: auto; display: block; }
        #menu-container { 
            position: fixed; 
            top: 50%; 
            right: -1.4rem; /* Hide button partially off-screen */
            transform: translateY(-50%); 
            z-index: 50;
            transition: right 0.2s ease-in-out; /* Add transition for hover effect */
        }
        #menu-container:hover {
            right: 0.5rem; /* Slide out on hover */
        }
        #menu-btn {
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 9999px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background-color 0.2s;
        }
        #menu-btn:hover { 
            transform: scale(1.05); 
            background-color: rgba(255, 255, 255, 0.7);
        }
        #menu-dropdown {
            position: absolute; bottom: 50%; right: 100%;
            transform: translateY(50%);
            width: 150px;
            margin-right: 0.75rem;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            opacity: 0;
            transform-origin: right center;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
        }
        #menu-dropdown.active { opacity: 1; transform: translateY(50%) scale(1); pointer-events: auto; }
        #menu-dropdown button { width: 100%; text-align: left; padding: 0.75rem 1rem; transition: background-color 0.2s; }
        #menu-dropdown button:hover { background-color: rgba(0, 0, 0, 0.05); }
        #turn-indicator-container {
            position: fixed;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 40;
        }
        #random-result-box {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            padding: 2rem 4rem;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 2rem;
            font-size: 8rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #random-result-box.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .first-player-highlight {
            color: #FFD700 !important;
            text-shadow: -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff, 0 0 15px #FFD700;
        }
        .life-display {
            font-size: clamp(3rem, 20vmin, 10rem); /* Dynamic Font Size */
        }
        .damage-display {
            font-weight: 900;
            color: #f87171; /* A lighter red for better visibility on dark backgrounds */
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
        }
        @keyframes life-pop-fade {
            0% { transform: translate(-50%, 0) scale(0.9); opacity: 1; }
            66% { transform: translate(-50%, -20px) scale(1); opacity: 1; } /* Hold for 1s of 1.5s total */
            100% { transform: translate(-50%, -60px) scale(1.1); opacity: 0; }
        }
        .life-change-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: clamp(1.5rem, 8vmin, 3rem);
            font-weight: 700;
            pointer-events: none;
            z-index: 26;
            animation: life-pop-fade 1.5s ease-out forwards;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center h-screen">

    <!-- Game setup controls -->
    <div id="setup-controls" class="bg-white p-4 rounded-2xl shadow-xl w-full max-w-4xl mx-auto text-center m-auto">
        <div class="flex justify-end mb-2">
            <select id="language-selector" class="p-1 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200 text-sm">
                <option value="th">ไทย</option>
                <option value="en" selected>English</option>
            </select>
        </div>
        <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-2" data-lang-key="appTitle"></h1>
        <div class="setup-image-container">
            <img src="CrayneLogo.jpg" alt="Crayne Fractured Empire Logo" class="setup-image">
        </div>
        <div class="flex flex-col items-center justify-center">
             <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4">
                <div class="flex items-center space-x-2 w-full sm:w-auto">
                    <label for="player-count" class="text-md sm:text-lg font-semibold text-gray-700" data-lang-key="playerCountLabel"></label>
                    <select id="player-count" class="p-1 sm:p-2 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200">
                        <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option>
                    </select>
                </div>
                <button id="start-btn" class="w-full sm:w-auto py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="startButton"></button>
            </div>
            <div id="color-preview" class="mt-4 flex justify-center items-center space-x-2 h-8"></div>
        </div>
    </div>
    
    <!-- Player cards container -->
    <div id="players-container" class="w-full max-w-4xl mx-auto flex-grow grid grid-cols-1 sm:grid-cols-2 min-h-0"></div>

    <!-- Next Turn Button Container -->
    <div id="next-turn-container" class="hidden fixed inset-0 flex items-center justify-center z-30 pointer-events-none">
        <div class="flex items-center space-x-4 pointer-events-auto">
            <button id="undo-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold p-3 rounded-full shadow-lg transition-transform active:scale-90">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"></path></svg>
            </button>
            <button id="next-turn-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg" data-lang-key="next_turn_btn"></button>
        </div>
    </div>

    <!-- Floating Menu Container -->
    <div id="menu-container" class="hidden">
        <div class="relative">
            <button id="menu-btn" class="text-gray-600">
                <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
            </button>
            <div id="menu-dropdown" class="text-gray-800">
                <button id="restart-game-btn" data-lang-key="menuRestart"></button>
                <button id="toggle-fullscreen-btn" data-lang-key="menuFullscreen"></button>
                <button id="random-btn" data-lang-key="menuRandom"></button>
            </div>
        </div>
    </div>

    <!-- Turn Log Indicator -->
    <div id="turn-indicator-container" class="hidden">
         <button id="turn-log-indicator" class="bg-gray-800 text-white text-xs font-bold w-8 h-8 rounded-full flex items-center justify-center border-2 border-white shadow-md">
            1
        </button>
    </div>

    <!-- Random Number Display -->
    <div id="random-result-box" class="hidden"></div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4 cursor-pointer">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full transform scale-100 transition-transform duration-300 cursor-default">
            <h2 class="text-4xl font-extrabold text-red-500 mb-4" data-lang-key="gameOverTitle"></h2>
            <p id="winner-message" class="text-xl font-bold text-gray-700 mb-6"></p>
            <button id="modal-reset-btn" class="py-3 px-6 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="newGameButton"></button>
        </div>
    </div>

    <!-- Log Modal -->
    <div id="log-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-lg h-3/4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800" data-lang-key="logTitle">Game Log</h2>
                <button id="close-log-btn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="log-content" class="flex-grow overflow-y-auto bg-gray-100 p-4 rounded-lg"></div>
        </div>
    </div>

    <p id="version-display" class="fixed bottom-2 right-3 text-xs text-gray-400 select-none z-10">v3.0.0-multitouch</p>

    <script>
        // --- Constants ---
        const STARTING_LIFE = { 2: 30, default: 60 };
        const CUSTOM_ORDERS = { 2: [1, 2], 3: [1, 2, 3], 4: [1, 2, 4, 3], 5: [1, 2, 3, 5, 4], 6: [1, 2, 3, 6, 5, 4] };
        
        const COLOR_FAMILIES = [
            // Reds
            [ { name: 'แดง', name_en: 'Red', tailwindClass: 'bg-red-600', textColorClass: 'text-red-600' }, { name: 'กุหลาบ', name_en: 'Rose', tailwindClass: 'bg-rose-500', textColorClass: 'text-rose-500' }, { name: 'ชมพู', name_en: 'Pink', tailwindClass: 'bg-pink-500', textColorClass: 'text-pink-500' }, ],
            // Blues
            [ { name: 'น้ำเงิน', name_en: 'Blue', tailwindClass: 'bg-blue-600', textColorClass: 'text-blue-600' }, { name: 'ท้องฟ้า', name_en: 'Sky', tailwindClass: 'bg-sky-500', textColorClass: 'text-sky-500' }, { name: 'คราม', name_en: 'Indigo', tailwindClass: 'bg-indigo-500', textColorClass: 'text-indigo-500' }, ],
            // Greens
            [ { name: 'เขียว', name_en: 'Green', tailwindClass: 'bg-green-600', textColorClass: 'text-green-600' }, { name: 'มรกต', name_en: 'Emerald', tailwindClass: 'bg-emerald-500', textColorClass: 'text-emerald-500' }, { name: 'ฟ้าอมเขียว', name_en: 'Teal', tailwindClass: 'bg-teal-500', textColorClass: 'text-teal-500' }, { name: 'เขียวมะนาว', name_en: 'Lime', tailwindClass: 'bg-lime-500', textColorClass: 'text-lime-500' }, ],
            // Purples
            [ { name: 'ม่วง', name_en: 'Purple', tailwindClass: 'bg-purple-600', textColorClass: 'text-purple-600' }, { name: 'ไวโอเล็ต', name_en: 'Violet', tailwindClass: 'bg-violet-600', textColorClass: 'text-violet-600' }, ],
            // Yellows / Oranges
            [ { name: 'เหลือง', name_en: 'Yellow', tailwindClass: 'bg-yellow-400', textColorClass: 'text-yellow-400' }, { name: 'เหลืองอำพัน', name_en: 'Amber', tailwindClass: 'bg-amber-500', textColorClass: 'text-amber-500' }, { name: 'ส้ม', name_en: 'Orange', tailwindClass: 'bg-orange-500', textColorClass: 'text-orange-500' }, ],
            // Grays / Special
            [ { name: 'เทา', name_en: 'Slate', tailwindClass: 'bg-slate-500', textColorClass: 'text-slate-500' }, { name: 'ฟ้า', name_en: 'Cyan', tailwindClass: 'bg-cyan-500', textColorClass: 'text-cyan-500' }, ]
        ];

        const DEFEAT_TAUNTS = {
            th: [ 
                "อ่อนว่ะ", "ไอกาก", "ภาระทีมชัดๆ", "สมน้ำหน้า 555", 
                "แค่นี้ก็ไม่รอด สัส", "ไปเกิดใหม่ไป๊", "ไหวป่ะเนี่ย?", "จบเกม...สำหรับนายอะนะ",
                "เพิ่มชีวิตอีกสักร้อยมะ?", "มันจ้าซะเหลือเกิน!!", "ไอ้สอง ให้พี่เดินสะดวกเถอะ", "นิ่มแบบนี้ คนหรือขี้วะ!",
                "ไปหวันซะละ", "รีบไปไหน แม่ใช้ไปซื้อน้ำปลาเหรอ", "อะเหื้อ!! ฝากลูกเมียข้าด้วย", "ไว้เจอกันใหม่นร้าา",
                "เก่งเกิ๊น...จนแพ้", "นี่เล่นเอาฮาใช่ปะ?", "RIP", "ตัวถ่วงที่แท้ทรู",
                "ไปนั่งสมาธิไป", "เกมนี้ไม่เหมาะกับคนอ่อนแอ", "ขอน้ำใบบัวบกหน่อย", "ยืนเฉยๆ เขาก็ชนะ",
                "ค่าจ้างเท่าไหร่เนี่ย?", "เล่นเพื่อสุขภาพ", "บทน้อยจังวะ", "ตายอย่างสงบ ศพสีชมพู",
                "สวยงามตามท้องเรื่อง", "เกมพลิก...ลงหลุม"
            ],
            en: [ 
                "gg no re", "Get rekt", "uninstall pls", "So bad lol", 
                "Was that your best?", "Sit down.", "You're a liability.", "Better luck next life.",
                "Need a hundred more life?", "So bright I can't see!", "Hey, let the pro play.", "Are you a player or a pillow?",
                "Gone with the wind.", "In a hurry? Mom needs fish sauce?", "Ugh!! Take care of my family.", "See ya next time!",
                "Too good... at losing.", "Is this a joke to you?", "RIP", "The real MVP... Most Valuable Burden.",
                "Go meditate or something.", "This game ain't for the weak.", "Need a healing potion?", "He won by doing nothing.",
                "How much did they pay you?", "Just playing for fun, right?", "Your part was too short.", "A beautiful death.",
                "Just as the prophecy foretold.", "The plot twist... into a grave."
            ]
        };

        const TRANSLATIONS = {
            'th': { title: 'เครื่องนับ Influence Crayne', appTitle: 'เครื่องนับ Influence Crayne', playerCountLabel: 'จำนวนผู้เล่น:', startButton: 'เริ่มเกม', gameOverTitle: 'เกมจบแล้ว!', newGameButton: 'เริ่มเกมใหม่', ready: 'พร้อม', defeated: 'แพ้แล้ว', block: 'บล็อก', winnerMsg: (c) => `ผู้เล่น ${c} เป็นผู้ชนะ!`, noWinnerMsg: 'ผู้เล่นทั้งหมดแพ้แล้ว!', menuRestart: 'รีสตาร์ท', menuFullscreen: 'ขยายเต็มจอ', menuExitFullscreen: 'ย่อหน้าจอ', menuRandom: 'สุ่มเลข', next_turn_btn: 'เริ่มรอบถัดไป', logTitle: 'บันทึกเกม', logTurn: (t) => `เทิร์นที่ ${t}` },
            'en': { title: 'Crayne Influence Counter', appTitle: 'Crayne Influence Counter', playerCountLabel: 'Players:', startButton: 'Start Game', gameOverTitle: 'Game Over!', newGameButton: 'New Game', ready: 'Ready', defeated: 'Defeated', block: 'Block', winnerMsg: (c) => `Player ${c} wins!`, noWinnerMsg: 'All players have been defeated!', menuRestart: 'Restart', menuFullscreen: 'Fullscreen', menuExitFullscreen: 'Exit Fullscreen', menuRandom: 'Random', next_turn_btn: 'Next Turn', logTitle: 'Game Log', logTurn: (t) => `Turn ${t}` }
        };

        // --- Game State ---
        const gameState = {
            players: [],
            initialPlayerCount: 0,
            firstPlayerId: null,
            currentLang: localStorage.getItem('appLang') || 'th',
            isBuyPhase: false,
            turnCount: 0,
            gameLog: [],
            previewColors: [],
            previousPlayerState: null 
        };

        // --- DOM Elements ---
        const ui = {
            playerCountSelector: document.getElementById('player-count'),
            playersContainer: document.getElementById('players-container'),
            startBtn: document.getElementById('start-btn'),
            setupControls: document.getElementById('setup-controls'),
            gameOverModal: document.getElementById('game-over-modal'),
            winnerMessage: document.getElementById('winner-message'),
            modalResetBtn: document.getElementById('modal-reset-btn'),
            languageSelector: document.getElementById('language-selector'),
            menuContainer: document.getElementById('menu-container'),
            menuBtn: document.getElementById('menu-btn'),
            menuDropdown: document.getElementById('menu-dropdown'),
            restartGameBtn: document.getElementById('restart-game-btn'),
            toggleFullscreenBtn: document.getElementById('toggle-fullscreen-btn'),
            randomBtn: document.getElementById('random-btn'),
            turnLogIndicator: document.getElementById('turn-log-indicator'),
            turnIndicatorContainer: document.getElementById('turn-indicator-container'),
            randomResultBox: document.getElementById('random-result-box'),
            versionDisplay: document.getElementById('version-display'),
            nextTurnContainer: document.getElementById('next-turn-container'),
            nextTurnBtn: document.getElementById('next-turn-btn'),
            undoBtn: document.getElementById('undo-btn'),
            logModal: document.getElementById('log-modal'),
            logContent: document.getElementById('log-content'),
            closeLogBtn: document.getElementById('close-log-btn'),
            colorPreview: document.getElementById('color-preview')
        };
        
        // --- Utility Functions ---
        const shuffleArray = (array) => {
            const newArr = [...array];
            for (let i = newArr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
            }
            return newArr;
        };

        // --- UI Rendering ---
        
        const updateColorPreview = () => {
            const count = parseInt(ui.playerCountSelector.value);
            const shuffledFamilies = shuffleArray(COLOR_FAMILIES);
            const selectedFamilies = shuffledFamilies.slice(0, count);
            const finalColors = selectedFamilies.map(family => {
                return family[Math.floor(Math.random() * family.length)];
            });
            gameState.previewColors = finalColors;
            ui.colorPreview.innerHTML = '';
            gameState.previewColors.forEach(color => {
                const circle = document.createElement('div');
                circle.className = `w-6 h-6 rounded-full shadow-md transition-all duration-300 ${color.tailwindClass}`;
                ui.colorPreview.appendChild(circle);
            });
        };

        const createPlayerCard = (player) => {
            const playerCard = document.createElement('div');
            playerCard.id = `player-card-${player.id}`;
            const isTwoPlayerMode = gameState.initialPlayerCount === 2;
            const fontSizes = {
                stats: isTwoPlayerMode ? 'text-6xl font-bold' : 'text-2xl sm:text-3xl md:text-4xl font-bold',
                block: isTwoPlayerMode ? 'text-4xl font-bold' : 'text-xl sm:text-2xl font-bold',
                label: isTwoPlayerMode ? 'text-lg' : 'text-xs',
                readyBtn: isTwoPlayerMode ? 'p-3 text-lg' : 'p-2 text-sm',
                smallBtn: isTwoPlayerMode ? 'w-8 h-8' : 'w-4 h-4 sm:w-5 sm:h-5',
                mediumBtn: isTwoPlayerMode ? 'w-10 h-10' : 'w-5 h-5 sm:w-6 sm:h-6',
                largeBtn: isTwoPlayerMode ? 'w-10 h-10 text-3xl' : 'w-7 h-7 sm:w-8 sm:h-8 text-xl sm:text-2xl',
            };
            playerCard.innerHTML = `
                <div class="card-content p-1 sm:p-2 flex flex-col items-center justify-between flex-grow relative">
                    <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-0">
                        <div class="life-container relative flex items-baseline justify-center">
                            <span class="life-display font-extrabold text-white"></span>
                        </div>
                    </div>
                    <div class="relative z-10 w-full flex items-center justify-between flex-shrink-0 flex-wrap space-x-1 text-white"></div>
                    <div class="relative z-10 flex-grow w-full flex items-center justify-between px-2">
                        <button data-player-id="${player.id}" data-action="decrement-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-red-500 bg-opacity-80 hover:bg-red-600 rounded-full shadow-lg">-</button>
                        <button data-player-id="${player.id}" data-action="increment-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-green-500 bg-opacity-80 hover:bg-green-600 rounded-full shadow-lg">+</button>
                    </div>
                    <div class="relative z-10 flex justify-center items-center space-x-2 w-full flex-shrink-0 mt-auto text-white">
                        <div class="flex flex-col items-center flex-1 min-w-0">
                            <span class="${fontSizes.label} font-semibold">ATK</span>
                            <div class="flex items-center space-x-0.5">
                                <button data-player-id="${player.id}" data-action="decrement-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button>
                                <span class="atk-display ${fontSizes.stats}"></span>
                                <button data-player-id="${player.id}" data-action="increment-atk" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button>
                            </div>
                        </div>
                        <div class="damage-container flex-shrink-0 w-16 sm:w-20 md:w-24 flex items-center justify-center"></div>
                        <div class="flex flex-col items-center flex-1 min-w-0">
                             <span class="${fontSizes.label} font-semibold">DEF</span>
                            <div class="flex items-center space-x-0.5">
                                <button data-player-id="${player.id}" data-action="decrement-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button>
                                <span class="def-display ${fontSizes.stats}"></span>
                                <button data-player-id="${player.id}" data-action="increment-def" class="${fontSizes.mediumBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="defeated-overlay" style="display: none;">
                    <span class="text-2xl font-extrabold" data-lang-key="defeated"></span>
                    <span class="taunt-text text-lg italic mt-2 text-red-300"></span>
                </div>
            `;
            return playerCard;
        };

        const updatePlayerCard = (player) => {
            const card = document.getElementById(`player-card-${player.id}`);
            if (!card) return;
            card.className = `${player.tailwindClass} text-white shadow-xl transform transition-all duration-300 relative overflow-hidden flex-1 flex flex-col justify-between`;
            if (gameState.initialPlayerCount === 2 ? player.id === 1 : player.id <= Math.ceil(gameState.initialPlayerCount / 2)) {
                card.classList.add('rotate-180');
            }
            const defeatedOverlay = card.querySelector('.defeated-overlay');
            const tauntText = card.querySelector('.taunt-text');
            if (player.isDefeated) {
                card.classList.add('opacity-40');
                defeatedOverlay.style.display = 'flex';
                // Assign a taunt only once
                if (!player.defeatTaunt) {
                    const taunts = DEFEAT_TAUNTS[gameState.currentLang];
                    player.defeatTaunt = taunts[Math.floor(Math.random() * taunts.length)];
                }
                tauntText.textContent = `"${player.defeatTaunt}"`;
            } else {
                card.classList.remove('opacity-40');
                defeatedOverlay.style.display = 'none';
            }
            const lifeDisplay = card.querySelector('.life-display');
            lifeDisplay.textContent = player.life;
            lifeDisplay.classList.toggle('first-player-highlight', player.id === gameState.firstPlayerId && !player.isDefeated);
            card.querySelector('.atk-display').textContent = player.atk;
            card.querySelector('.def-display').textContent = player.def;
            const damageContainer = card.querySelector('.damage-container');
            if (player.lastDamageTaken > 0 && gameState.isBuyPhase) {
                const fontSizeClass = gameState.initialPlayerCount === 2 ? 'text-6xl font-bold' : 'text-2xl sm:text-3xl md:text-4xl font-bold';
                damageContainer.innerHTML = `<span class="damage-display ${fontSizeClass}">-${player.lastDamageTaken}</span>`;
            } else {
                damageContainer.innerHTML = '';
            }
            const blockContainer = card.querySelector('.z-10.w-full');
            const t = (key) => TRANSLATIONS[gameState.currentLang][key];
            const activePlayersCount = gameState.players.filter(p => !p.isDefeated).length;
            const isTwoPlayerMode = gameState.initialPlayerCount === 2;
            const fontSizes = {
                block: isTwoPlayerMode ? 'text-4xl font-bold' : 'text-xl sm:text-2xl font-bold',
                label: isTwoPlayerMode ? 'text-lg' : 'text-xs',
                readyBtn: isTwoPlayerMode ? 'p-3 text-lg' : 'p-2 text-sm',
                smallBtn: isTwoPlayerMode ? 'w-8 h-8' : 'w-4 h-4 sm:w-5 sm:h-5',
            };
            let blockHTML = '';
            if ((gameState.initialPlayerCount > 2 && activePlayersCount === 2) || isTwoPlayerMode) {
                 blockHTML = `<div class="flex-1"></div><div class="flex flex-col items-center flex-1 min-w-0"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="block-display ${fontSizes.block}">${player.block}</span><button data-player-id="${player.id}" data-action="increment-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex-1 flex justify-center"><button data-player-id="${player.id}" data-action="ready" class="ready-btn ${fontSizes.readyBtn} bg-white text-gray-800 font-semibold rounded-xl shadow-lg active:shadow-none active:translate-y-1 transform">${t('ready')}</button></div>`;
            } else {
                const activePlayerOrder = CUSTOM_ORDERS[gameState.initialPlayerCount].filter(id => gameState.players.find(p => p.id === id && !p.isDefeated));
                const currentPlayerIndex = activePlayerOrder.indexOf(player.id);
                let leftOpponentColorClass = 'bg-gray-400', rightOpponentColorClass = 'bg-gray-400';
                if (activePlayerOrder.length > 1 && currentPlayerIndex !== -1) {
                    const leftOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex + 1) % activePlayerOrder.length]);
                    const rightOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                    if (leftOpponent) leftOpponentColorClass = leftOpponent.tailwindClass;
                    if (rightOpponent) rightOpponentColorClass = rightOpponent.tailwindClass;
                }
                blockHTML = `<div class="flex flex-col items-center flex-1 min-w-0"><div class="flex items-center space-x-1 justify-center"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="w-3 h-3 sm:w-4 sm:h-4 rounded-full ${leftOpponentColorClass} ring-2 ring-white"></div></div><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="left-block-display ${fontSizes.block}">${player.leftBlock}</span><button data-player-id="${player.id}" data-action="increment-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div><div class="flex-shrink-0"><button data-player-id="${player.id}" data-action="ready" class="ready-btn ${fontSizes.readyBtn} bg-white text-gray-800 font-semibold rounded-xl shadow-lg active:shadow-none active:translate-y-1 transform">${t('ready')}</button></div><div class="flex flex-col items-center flex-1 min-w-0"><div class="flex items-center space-x-1 justify-center"><span class="${fontSizes.label} font-semibold">${t('block')}</span><div class="w-3 h-3 sm:w-4 sm:h-4 rounded-full ${rightOpponentColorClass} ring-2 ring-white"></div></div><div class="flex items-center space-x-0.5 mt-1"><button data-player-id="${player.id}" data-action="decrement-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">-</button><span class="right-block-display ${fontSizes.block}">${player.rightBlock}</span><button data-player-id="${player.id}" data-action="increment-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 hover:bg-opacity-50 text-white font-bold rounded-full">+</button></div></div>`;
            }
            blockContainer.innerHTML = blockHTML;
            const readyBtn = card.querySelector('.ready-btn');
            readyBtn.textContent = t('ready');
            readyBtn.classList.toggle('bg-green-500', player.isReady);
            readyBtn.classList.toggle('hover:bg-green-600', player.isReady);
            readyBtn.classList.toggle('text-white', player.isReady);
            readyBtn.classList.toggle('bg-white', !player.isReady);
            readyBtn.classList.toggle('text-gray-800', !player.isReady);
            const shouldLockControls = player.isDefeated || player.isReady || gameState.isBuyPhase;
            card.querySelectorAll(`[data-action$="-atk"], [data-action$="-def"], [data-action*="Block"]`).forEach(btn => btn.disabled = shouldLockControls);
            card.querySelectorAll(`[data-action$="-life"]`).forEach(btn => btn.disabled = player.isDefeated);
            readyBtn.disabled = player.isDefeated || gameState.isBuyPhase;
        };

        const showLifeChangeIndicator = (playerId, totalChange) => {
            const card = document.getElementById(`player-card-${playerId}`);
            if (!card) return;
            const existingIndicator = card.querySelector('.life-change-indicator');
            if (existingIndicator) existingIndicator.remove();
            if (totalChange === 0) return;
            const indicator = document.createElement('div');
            indicator.className = 'life-change-indicator';
            const sign = totalChange > 0 ? '+' : '';
            indicator.textContent = `${sign}${totalChange}`;
            indicator.style.color = totalChange > 0 ? '#a7f3d0' : '#fecaca';
            const cardContent = card.querySelector('.card-content');
            if (cardContent) {
                cardContent.appendChild(indicator);
                setTimeout(() => indicator.remove(), 1400);
            }
        };

        const updateFullscreenButton = () => {
            const t = (key) => TRANSLATIONS[gameState.currentLang][key];
            if (document.fullscreenElement) {
                ui.toggleFullscreenBtn.textContent = t('menuExitFullscreen');
                ui.toggleFullscreenBtn.dataset.langKey = 'menuExitFullscreen';
            } else {
                ui.toggleFullscreenBtn.textContent = t('menuFullscreen');
                ui.toggleFullscreenBtn.dataset.langKey = 'menuFullscreen';
            }
        };

        const setLanguage = (lang) => {
            gameState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (TRANSLATIONS[lang][key] && typeof TRANSLATIONS[lang][key] === 'string') {
                    el.textContent = TRANSLATIONS[lang][key];
                }
            });
            updateFullscreenButton();
            if (gameState.players.length > 0) {
                 gameState.players.forEach(p => updatePlayerCard(p));
            }
        };

        // --- Game Logic ---

        const initPlayers = () => {
            const startingLife = STARTING_LIFE[gameState.initialPlayerCount] || STARTING_LIFE.default;
            const gameColors = gameState.previewColors;
            gameState.players = Array.from({ length: gameState.initialPlayerCount }, (_, i) => ({
                id: i + 1, ...gameColors[i], life: startingLife,
                atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0,
                isReady: false, isDefeated: false, lastDamageTaken: 0, manualLifeChange: 0,
                defeatTaunt: null // Reset taunt on new game
            }));
            if (gameState.players.length > 0) {
                gameState.firstPlayerId = gameState.players[Math.floor(Math.random() * gameState.players.length)].id;
            }
            gameState.turnCount = 1;
            gameState.gameLog = [];
            ui.turnLogIndicator.textContent = gameState.turnCount;
            ui.playersContainer.innerHTML = '';
            let gridClass = 'grid-cols-2';
            if (gameState.initialPlayerCount <= 2) gridClass = 'grid-cols-1';
            if (gameState.initialPlayerCount === 3) gridClass = 'grid-cols-2 sm:grid-cols-2';
            if (gameState.initialPlayerCount >= 5) gridClass = 'grid-cols-2 md:grid-cols-3';
            ui.playersContainer.className = `w-full max-w-4xl mx-auto flex-grow grid min-h-0 ${gridClass}`;
            gameState.players.forEach((player) => {
                const playerCard = createPlayerCard(player);
                if (gameState.initialPlayerCount === 3 && player.id === 3) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'col-span-full flex justify-center';
                    wrapper.appendChild(playerCard);
                    ui.playersContainer.appendChild(wrapper);
                } else {
                    ui.playersContainer.appendChild(playerCard);
                }
            });
             if (gameState.initialPlayerCount === 5) {
                const placeholder = document.createElement('div');
                placeholder.className = 'hidden md:block md:col-start-1';
                ui.playersContainer.insertBefore(placeholder, ui.playersContainer.children[3]);
            }
            gameState.players.forEach(p => updatePlayerCard(p));
        };

        const startGame = () => {
            gameState.initialPlayerCount = parseInt(ui.playerCountSelector.value);
            const orientation = gameState.initialPlayerCount === 2 ? 'portrait-primary' : 'landscape';
            goFullscreen(orientation);
            initPlayers();
            ui.setupControls.classList.add('hidden');
            ui.gameOverModal.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden');
            ui.turnIndicatorContainer.classList.remove('hidden');
            ui.versionDisplay.classList.add('hidden');
        };

        const resetGame = () => {
            Object.assign(gameState, { players: [], initialPlayerCount: 0, firstPlayerId: null, isBuyPhase: false, turnCount: 0, gameLog: [], previewColors: [], previousPlayerState: null });
            ui.nextTurnContainer.classList.add('hidden');
            ui.playersContainer.innerHTML = '';
            ui.setupControls.classList.remove('hidden');
            ui.gameOverModal.classList.add('hidden');
            ui.menuContainer.classList.add('hidden');
            ui.turnIndicatorContainer.classList.add('hidden');
            ui.menuDropdown.classList.remove('active');
            ui.versionDisplay.classList.remove('hidden');
            if (document.fullscreenElement) document.exitFullscreen();
            updateColorPreview();
            setLanguage(gameState.currentLang);
        };
        
        const logRoundSummary = (playersBefore, damageDealt) => {
            let logEntry = gameState.gameLog.find(entry => entry.turn === gameState.turnCount);
            if (!logEntry) {
                logEntry = { turn: gameState.turnCount, actions: [] };
                gameState.gameLog.push(logEntry);
            }
            logEntry.actions = []; 

            playersBefore.forEach(player => {
                const playerName = gameState.currentLang === 'en' ? player.name_en : player.name;
                const finalDamage = Math.max(0, damageDealt[player.id] - player.def);
                const lifeAtTurnStart = player.life - player.manualLifeChange;
                const lifeAfterCombat = player.life - finalDamage;

                let summary = `P${player.id} (${playerName}): `;
                
                const isTwoPlayerOrEndGame = playersBefore.length === 2 || gameState.initialPlayerCount === 2;
                if (isTwoPlayerOrEndGame) {
                    summary += `[ATK ${player.atk}, DEF ${player.def}, BLK ${player.block}] `;
                } else {
                    summary += `[ATK ${player.atk}, DEF ${player.def}, BLK L:${player.leftBlock} R:${player.rightBlock}] `;
                }

                let lifeSummary = `Life ${lifeAtTurnStart}`;
                if (player.manualLifeChange !== 0) {
                    const sign = player.manualLifeChange > 0 ? '+' : '';
                    lifeSummary += ` → ${player.life} (${sign}${player.manualLifeChange})`;
                }
                if (finalDamage > 0) {
                    lifeSummary += ` → ${lifeAfterCombat} (-${finalDamage} dmg)`;
                } else if (player.manualLifeChange === 0) {
                    lifeSummary += ` → ${lifeAfterCombat}`;
                }
                
                summary += lifeSummary;
                logEntry.actions.push(summary);
            });
        };

        const applyDamage = () => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length < 2) return [];
            const playersBeforeDamage = JSON.parse(JSON.stringify(activePlayers));
            activePlayers.forEach(p => p.lastDamageTaken = 0);
            const damageTaken = gameState.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
            if (activePlayers.length === 2) {
                const [p1, p2] = activePlayers;
                damageTaken[p2.id] += Math.max(0, p1.atk - p2.block);
                damageTaken[p1.id] += Math.max(0, p2.atk - p1.block);
            } else {
                const activePlayerOrder = CUSTOM_ORDERS[gameState.initialPlayerCount].filter(id => activePlayers.some(p => p.id === id));
                activePlayerOrder.forEach((attackerId, index) => {
                    const attacker = gameState.players.find(p => p.id === attackerId);
                    const leftDefender = gameState.players.find(p => p.id === activePlayerOrder[(index + 1) % activePlayerOrder.length]);
                    const rightDefender = gameState.players.find(p => p.id === activePlayerOrder[(index - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                    if (leftDefender) damageTaken[leftDefender.id] += Math.max(0, attacker.atk - leftDefender.rightBlock);
                    if (rightDefender) damageTaken[rightDefender.id] += Math.max(0, attacker.atk - rightDefender.leftBlock);
                });
            }
            const newlyDefeatedPlayers = [];
            activePlayers.forEach(p => {
                const finalDamage = Math.max(0, damageTaken[p.id] - p.def);
                if (finalDamage > 0) {
                    p.lastDamageTaken = finalDamage;
                    p.life -= finalDamage;
                    if (p.life <= 0 && !p.isDefeated) {
                        newlyDefeatedPlayers.push(p);
                    }
                }
            });
            logRoundSummary(playersBeforeDamage, damageTaken);
            return newlyDefeatedPlayers;
        };

        const checkGameOver = (newlyDefeatedPlayers) => {
            newlyDefeatedPlayers.forEach(p => p.isDefeated = true);
            const remainingPlayers = gameState.players.filter(p => !p.isDefeated);
            let winner = null;
            let isGameOver = false;
            if (remainingPlayers.length === 1) {
                winner = remainingPlayers[0];
                isGameOver = true;
            } else if (remainingPlayers.length === 0) {
                 isGameOver = true;
                 if (newlyDefeatedPlayers.length > 1) {
                    newlyDefeatedPlayers.sort((a, b) => b.life - a.life);
                    if (newlyDefeatedPlayers[0].life > newlyDefeatedPlayers[1].life) {
                        winner = newlyDefeatedPlayers[0];
                    }
                 }
            }
            if (isGameOver) {
                gameState.isGameOver = true;
                setTimeout(() => {
                    const t = (key, arg) => TRANSLATIONS[gameState.currentLang][key](arg);
                    if (winner) {
                        ui.winnerMessage.textContent = t('winnerMsg', gameState.currentLang === 'en' ? winner.name_en : winner.name);
                        ui.winnerMessage.className = `text-xl font-bold ${winner.textColorClass} mb-6`;
                    } else {
                        ui.winnerMessage.textContent = t('noWinnerMsg');
                        ui.winnerMessage.className = `text-xl font-bold text-gray-700 mb-6`;
                    }
                    ui.gameOverModal.classList.remove('hidden');
                }, 2000);
            }
            return isGameOver;
        };

        const passFirstPlayerToken = () => {
            const fullOrder = CUSTOM_ORDERS[gameState.initialPlayerCount] || [];
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (fullOrder.length === 0 || !gameState.firstPlayerId || activePlayers.length < 2) {
                gameState.firstPlayerId = activePlayers.length > 0 ? activePlayers[0]?.id : null;
                return;
            };
            const startIndex = fullOrder.indexOf(gameState.firstPlayerId);
            if (startIndex === -1) {
                gameState.firstPlayerId = activePlayers[0]?.id;
                return;
            }
            for (let i = 1; i <= fullOrder.length; i++) {
                const nextPlayerId = fullOrder[(startIndex + i) % fullOrder.length];
                if (activePlayers.some(p => p.id === nextPlayerId)) {
                    gameState.firstPlayerId = nextPlayerId;
                    return;
                }
            }
            gameState.firstPlayerId = activePlayers[0]?.id;
        };

        const resetPlayerTurnStats = () => {
            gameState.players.forEach(p => {
                if (!p.isDefeated) {
                    Object.assign(p, { atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0 });
                }
            });
        };

        const handleRoundEnd = () => {
            gameState.previousPlayerState = JSON.parse(JSON.stringify(gameState.players));
            const newlyDefeatedPlayers = applyDamage();
            gameState.isBuyPhase = true;
            const isGameOver = checkGameOver(newlyDefeatedPlayers);
            gameState.players.forEach(p => updatePlayerCard(p));
            if (!isGameOver) {
                ui.nextTurnContainer.classList.remove('hidden');
            }
        };
        
        const startNextTurn = () => {
            gameState.previousPlayerState = null;
            gameState.isBuyPhase = false;
            ui.nextTurnContainer.classList.add('hidden');
            passFirstPlayerToken();
            resetPlayerTurnStats();
            gameState.turnCount++;
            ui.turnLogIndicator.textContent = gameState.turnCount;
            gameState.players.forEach(p => updatePlayerCard(p));
        };

        const handleUndo = () => {
            if (!gameState.previousPlayerState) return;
            gameState.players = JSON.parse(JSON.stringify(gameState.previousPlayerState));
            gameState.isBuyPhase = false;
            gameState.previousPlayerState = null;
            ui.nextTurnContainer.classList.add('hidden');
            gameState.players.forEach(p => updatePlayerCard(p));
        };

        const checkAllReady = () => {
            const newlyDefeated = gameState.players.filter(p => p.life <= 0 && !p.isDefeated);
            if (newlyDefeated.length > 0) {
                checkGameOver(newlyDefeated);
                newlyDefeated.forEach(p => updatePlayerCard(p));
            }
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length > 0 && activePlayers.every(p => p.isReady)) {
                handleRoundEnd();
            }
        };

        const goFullscreen = (orientation = 'landscape') => {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock(orientation).catch(() => {});
            }
        };

        const generateRandomNumber = () => {
            if (gameState.initialPlayerCount === 0) return;
            const randomNumber = Math.floor(Math.random() * (gameState.initialPlayerCount + 3)) + 1;
            ui.randomResultBox.textContent = randomNumber;
            ui.randomResultBox.classList.remove('hidden');
            setTimeout(() => ui.randomResultBox.classList.add('show'), 10);
            setTimeout(() => {
                ui.randomResultBox.classList.remove('show');
                setTimeout(() => ui.randomResultBox.classList.add('hidden'), 500);
            }, 3000);
        };

        const renderLog = () => {
            ui.logContent.innerHTML = '';
            const t = (key, arg) => TRANSLATIONS[gameState.currentLang][key](arg);
            [...gameState.gameLog].reverse().forEach(entry => {
                const turnHeader = document.createElement('h3');
                turnHeader.className = 'text-lg font-bold mt-4 mb-2 text-gray-700';
                turnHeader.textContent = t('logTurn', entry.turn);
                ui.logContent.appendChild(turnHeader);
                const actionList = document.createElement('ul');
                actionList.className = 'list-disc list-inside space-y-1 text-sm text-gray-600';
                entry.actions.forEach(action => {
                    const listItem = document.createElement('li');
                    listItem.textContent = action;
                    actionList.appendChild(listItem);
                });
                ui.logContent.appendChild(actionList);
            });
        };

        // --- Event Handlers ---

        const performPlayerAction = (playerId, action) => {
            const player = gameState.players.find(p => p.id === playerId);
            if (!player || player.isDefeated) return;
            if ((player.isReady || gameState.isBuyPhase) && !['ready', 'increment-life', 'decrement-life'].includes(action)) return;
            
            if (action === 'ready') {
                player.isReady = !player.isReady;
                checkAllReady();
            } else {
                const [operation, property] = action.split('-');
                if (property in player) {
                    const value = operation === 'increment' ? 1 : -1;
                    player[property] += value;
                    if (property === 'life') {
                        player.manualLifeChange += value;
                        showLifeChangeIndicator(player.id, player.manualLifeChange);
                    }
                    if (!property.toLowerCase().includes('life')) {
                        player[property] = Math.max(0, player[property]);
                    }
                }
            }
            updatePlayerCard(player);
        };

        const handleClickEvent = (event) => {
            const button = event.target.closest('button[data-action]');
            if (!button) return;
            const playerId = parseInt(button.dataset.playerId);
            const action = button.dataset.action;
            performPlayerAction(playerId, action);
        };

        const handleTouchEvent = (event) => {
            event.preventDefault(); // Prevents click events from firing too
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                if (targetElement) {
                    const button = targetElement.closest('button[data-action]');
                    if (button) {
                        const playerId = parseInt(button.dataset.playerId);
                        const action = button.dataset.action;
                        performPlayerAction(playerId, action);
                    }
                }
            }
        };
        
        // --- Initialization ---
        const bindEventListeners = () => {
            ui.startBtn.addEventListener('click', startGame);
            ui.modalResetBtn.addEventListener('click', resetGame);
            
            // Listen for both touch and click for universal compatibility
            ui.playersContainer.addEventListener('click', handleClickEvent);
            ui.playersContainer.addEventListener('touchstart', handleTouchEvent, { passive: false });

            ui.menuBtn.addEventListener('click', () => ui.menuDropdown.classList.toggle('active'));
            ui.restartGameBtn.addEventListener('click', resetGame);
            ui.nextTurnBtn.addEventListener('click', startNextTurn);
            ui.undoBtn.addEventListener('click', handleUndo);
            
            ui.toggleFullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    goFullscreen(gameState.initialPlayerCount === 2 ? 'portrait-primary' : 'landscape');
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                ui.menuDropdown.classList.remove('active');
            });
            document.addEventListener('fullscreenchange', updateFullscreenButton);

            ui.randomBtn.addEventListener('click', () => {
                generateRandomNumber();
                ui.menuDropdown.classList.remove('active');
            });
            ui.turnLogIndicator.addEventListener('click', () => {
                renderLog();
                ui.logModal.classList.remove('hidden');
            });
            ui.closeLogBtn.addEventListener('click', () => ui.logModal.classList.add('hidden'));
            ui.languageSelector.addEventListener('change', (event) => setLanguage(event.target.value));
            ui.playerCountSelector.addEventListener('change', updateColorPreview);
            ui.gameOverModal.addEventListener('click', (event) => {
                if (event.target === ui.gameOverModal) ui.gameOverModal.classList.add('hidden');
            });
        };

        document.addEventListener('DOMContentLoaded', () => {
            ui.languageSelector.value = gameState.currentLang;
            setLanguage(gameState.currentLang);
            updateColorPreview();
            bindEventListeners();
        });
    </script>
</body>
</html>
