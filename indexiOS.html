<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <title data-lang-key="title">Crayne Influence Counter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            width: 100vw;
            min-height: 100vh;
            box-sizing: border-box;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö iPhone ‡∏ó‡∏µ‡πà‡∏°‡∏µ notch ‡πÅ‡∏•‡∏∞ iOS 18 */
            padding-bottom: env(safe-area-inset-bottom);
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ bounce scroll ‡∏ö‡∏ô iOS */
            -webkit-overflow-scrolling: touch;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        .defeated-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(40, 10, 10, 0.6);
            color: #ff8a8a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(1px);
            -webkit-backdrop-filter: blur(1px);
            padding: 1rem;
            text-align: center;
            z-index: 30;
        }
        .setup-image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            max-width: 80%;
            height: auto;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin-left: auto;
            margin-right: auto;
        }
        .setup-image { width: 100%; height: auto; display: block; }
        #menu-container { 
            position: fixed; 
            top: 50%; 
            right: -1.4rem;
            transform: translateY(-50%); 
            z-index: 50;
            transition: all 0.3s ease-in-out;
            cursor: move;
            user-select: none;
        }
        
        #menu-container.dragging {
            transition: none !important;
        }
        #menu-container:hover:not(.dragging) {
            right: 0.5rem;
        }
        #menu-container.bottom-center {
            top: auto;
            bottom: 1rem;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
        }
        #menu-container.bottom-center:hover { right: auto; }

        #menu-btn {
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 9999px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background-color 0.2s;
        }
        #menu-btn:hover { 
            transform: scale(1.05); 
            background-color: rgba(255, 255, 255, 0.7);
        }
        #menu-dropdown {
            position: absolute; 
            bottom: 50%; 
            right: 100%;
            transform: translateY(50%);
            width: 150px;
            margin-right: 0.75rem;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            opacity: 0;
            transform-origin: right center;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
        }
        
        /* ‡∏õ‡∏£‡∏±‡∏ö dropdown ‡πÄ‡∏°‡∏∑‡πà‡∏≠ menu ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢ */
        #menu-container.position-right #menu-dropdown {
            left: 100%;
            right: auto;
            bottom: 50%;
            top: auto;
            transform: translateY(50%);
            margin-left: 0.75rem;
            margin-right: 0;
            margin-bottom: 0;
            transform-origin: left center;
        }
        
        /* ‡∏õ‡∏£‡∏±‡∏ö dropdown ‡πÄ‡∏°‡∏∑‡πà‡∏≠ menu ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô */
        #menu-container.position-bottom #menu-dropdown {
            top: 100%;
            bottom: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            margin-top: 0.75rem;
            margin-left: 0;
            margin-right: 0;
            margin-bottom: 0;
            transform-origin: center top;
        }
        
        /* ‡∏õ‡∏£‡∏±‡∏ö dropdown ‡πÄ‡∏°‡∏∑‡πà‡∏≠ menu ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á */
        #menu-container.position-top #menu-dropdown {
            bottom: 100%;
            top: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            margin-bottom: 0.75rem;
            margin-left: 0;
            margin-right: 0;
            margin-top: 0;
            transform-origin: center bottom;
        }
        #menu-container.bottom-center #menu-dropdown {
            bottom: 100%;
            top: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%) scale(0.95);
            transform-origin: bottom center;
            margin-bottom: 0.75rem;
            margin-right: 0;
        }

        #menu-dropdown.active { opacity: 1; transform: translateY(50%) scale(1); pointer-events: auto; }
        #menu-container.bottom-center #menu-dropdown.active { transform: translateX(-50%) scale(1); }
        #menu-container.position-right #menu-dropdown.active { transform: translateY(50%) scale(1); }
        #menu-container.position-bottom #menu-dropdown.active { transform: translateX(-50%) scale(1); }
        #menu-container.position-top #menu-dropdown.active { transform: translateX(-50%) scale(1); }
        
        #menu-dropdown button { width: 100%; text-align: left; padding: 0.75rem 1rem; transition: background-color 0.2s; }
        #menu-dropdown button:hover { background-color: rgba(0, 0, 0, 0.05); }
        
        #turn-indicator-container {
            position: fixed;
            top: 50%;
            left: 1rem;
            transform: translateY(-50%);
            z-index: 40;
            transition: all 0.3s ease-in-out;
        }
        #turn-indicator-container.top-center { 
            top: 1rem; 
            left: 50%;
            transform: translateX(-50%); 
        }

        #random-result-box {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            padding: 2rem 4rem;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 2rem;
            font-size: 8rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #random-result-box.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .first-player-highlight {
            color: #FFD700 !important;
            text-shadow: -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff, 0 0 15px #FFD700;
        }
        .life-display {
            font-size: clamp(3rem, 20vmin, 10rem);
        }
        .damage-display {
            font-weight: 900;
            color: #f87171;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
        }
        @keyframes life-pop-fade {
            0% { transform: translate(-50%, 0) scale(0.9); opacity: 1; }
            66% { transform: translate(-50%, -20px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1.1); opacity: 0; }
        }
        .life-change-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: clamp(1.5rem, 8vmin, 3rem);
            font-weight: 700;
            pointer-events: none;
            z-index: 26;
            animation: life-pop-fade 1.5s ease-out forwards;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .content-wrapper {
            transition: transform 0.3s ease-in-out;
            width: 100%;
            height: 100%;
            position: relative;
        }
        .block-label {
            font-weight: 600;
            font-size: 0.65rem;
            line-height: 1;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        }
        
        /* ===== ROTATED CARDS STYLES - CONSOLIDATED ===== */
        .is-rotated-sideways {
            overflow: hidden;
        }
        
        /* Text sizing - responsive and clean */
        .is-rotated-sideways .life-display {
            font-size: clamp(2rem, 15vmin, 6rem) !important;
            line-height: 0.8 !important;
            margin: 0 !important;
        }
        .is-rotated-sideways .atk-display, .is-rotated-sideways .def-display {
            font-size: clamp(1.5rem, 8vmin, 3rem) !important;
        }
        .is-rotated-sideways .left-block-display, .is-rotated-sideways .right-block-display, .is-rotated-sideways .block-display {
            font-size: clamp(1rem, 6vmin, 2rem) !important;
        }
        
        /* Layout and positioning */
        .is-rotated-sideways > div { padding: 0.25rem !important; }
        .is-rotated-sideways .dual-block-ui, .is-rotated-sideways .single-block-ui {
            position: absolute !important;
            top: 0.25rem !important;
            left: 0.25rem !important;
            right: 0.25rem !important;
            z-index: 20 !important;
            justify-content: space-between !important;
        }
        .is-rotated-sideways .absolute.bottom-4 { bottom: 0.25rem !important; }
        .is-rotated-sideways .damage-container {
            width: auto !important;
            max-width: 2rem !important;
            overflow: visible !important;
        }
        
        /* Button styling */
        .is-rotated-sideways button {
            min-width: 1.5rem !important;
            min-height: 1.5rem !important;
            font-size: 0.75rem !important;
            transform: scale(0.8) !important;
        }
        .is-rotated-sideways .ready-btn {
            font-size: 0.625rem !important;
            padding: 0.125rem 0.25rem !important;
        }
        
        /* 6B Layout specific overrides */
        .layout-6b .is-rotated-sideways {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            height: 100% !important;
        }
        .layout-6b .is-rotated-sideways .life-display {
            font-size: clamp(1.8rem, 12vmin, 5rem) !important;
        }
        .layout-6b .is-rotated-sideways .atk-display, .layout-6b .is-rotated-sideways .def-display {
            font-size: clamp(1.2rem, 6vmin, 2.5rem) !important;
        }
        .layout-6b .is-rotated-sideways .dual-block-ui {
            gap: 0.25rem !important;
        }
        .layout-6b .is-rotated-sideways .dual-block-ui > div {
            flex: none !important;
            min-width: 0 !important;
        }
        
        /* Global block UI */
        .dual-block-ui, .single-block-ui {
            justify-content: space-between !important;
        }
        
        /* Ready button ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏°‡∏µ‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏î‡∏≤‡∏ö‡πÑ‡∏Ç‡∏ß‡πâ */
        .ready-btn {
            border-radius: 50% !important;
            width: 2.5rem !important;
            height: 2.5rem !important;
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 1.2rem !important;
            transition: all 0.2s ease !important;
        }
        
        .ready-btn:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3) !important;
        }
        
        /* ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏∏‡∏ô */
        .is-rotated-sideways .ready-btn {
            width: 1.8rem !important;
            height: 1.8rem !important;
            font-size: 0.8rem !important;
        }

        /* CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö aspect ratio adjustment (‡∏ß‡∏¥‡∏ò‡∏µ C - ‡∏ß‡∏±‡∏î‡∏Ç‡∏≠‡∏ö‡∏ï‡∏£‡∏á‡πÜ) */
        .rotation-adjusted {
            transform-origin: center center !important;
            position: relative !important;
        }
        
        .rotation-adjusted.is-rotated-sideways {
            /* ‡∏õ‡∏£‡∏±‡∏ö aspect ratio ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô */
            width: var(--card-width, 100%) !important;
            height: var(--card-height, 100%) !important;
            margin-left: var(--offset-x, 0) !important;
            margin-top: var(--offset-y, 0) !important;
            /* ‡∏´‡∏°‡∏∏‡∏ô 90 ‡∏≠‡∏á‡∏®‡∏≤ */
            transform: rotate(90deg) !important;
            transform-origin: center center !important;
        }
        
        .rotation-adjusted.is-rotated-sideways[style*="rotate(-90deg)"] {
            width: var(--card-width, 100%) !important;
            height: var(--card-height, 100%) !important;
            margin-left: var(--offset-x, 0) !important;
            margin-top: var(--offset-y, 0) !important;
            transform: rotate(-90deg) !important;
            transform-origin: center center !important;
        }
        .iphone-mode {
            height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 40px) !important;
            max-height: calc(100vh - 80px) !important;
            transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
        }
        
        .iphone-mode-container {
            padding-top: max(env(safe-area-inset-top), 20px) !important;
            padding-bottom: max(env(safe-area-inset-bottom), 20px) !important;
            padding-left: env(safe-area-inset-left) !important;
            padding-right: env(safe-area-inset-right) !important;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center h-screen">
    <div id="setup-controls" class="bg-white p-4 rounded-2xl shadow-xl w-full max-w-4xl mx-auto text-center m-auto">
        <div class="flex justify-end mb-2">
            <select id="language-selector" class="p-1 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200 text-sm">
                <option value="th">‡πÑ‡∏ó‡∏¢</option>
                <option value="en" selected>English</option>
            </select>
            <label class="flex items-center space-x-2 text-sm ml-4">
                <input type="checkbox" id="iphone-safearea-toggle" class="form-checkbox">
                <span>iPhone mode</span>
            </label>
        </div>

        <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-2" data-lang-key="appTitle"></h1>
        <div class="setup-image-container">
            <img src="CrayneLogo.jpg" alt="Crayne Fractured Empire Logo" class="setup-image" onerror="this.onerror=null;this.src='https://placehold.co/600x300/e2e8f0/4a5568?text=Crayne+Logo';">
        </div>
        <div class="flex flex-col items-center justify-center">
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4">
                <div class="flex items-center space-x-2 w-full sm:w-auto">
                    <label for="player-count" class="text-md sm:text-lg font-semibold text-gray-700" data-lang-key="playerCountLabel"></label>
                    <select id="player-count" class="p-1 sm:p-2 border-2 border-gray-300 rounded-xl focus:outline-none focus:border-blue-500 transition-all duration-200">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="3v">3 (V)</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="5B">5 (B)</option>
                        <option value="5C">5 (C)</option>
                        <option value="6">6</option>
                        <option value="6B">6 (B)</option>
                        <option value="6C">6 (C)</option>
                    </select>
                </div>
                <button id="start-btn" class="w-full sm:w-auto py-2 px-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-xl transition-colors duration-200 shadow-lg active:shadow-none active:translate-y-1 transform" data-lang-key="startButton"></button>
            </div>
            <div id="color-select-panel" class="mt-4 flex flex-wrap justify-center items-center gap-2"></div>
        </div>
        
        <div class="absolute bottom-4 left-4 text-left">
            <a href="https://vancobz21.github.io/stable3100.html" target="_blank" class="text-xs text-gray-400 hover:text-blue-500 transition-colors">
                Old Version
            </a>
        </div>
    </div>
    
    <div id="players-container" class="w-full h-full flex-grow grid min-h-0"></div>

    <div id="next-turn-container" class="hidden fixed inset-0 flex items-center justify-center z-30 pointer-events-none">
        <div class="flex items-center space-x-4 pointer-events-auto">
            <button id="undo-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold p-3 rounded-full shadow-lg transition-transform active:scale-90">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.333 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"></path></svg>
            </button>
            <button id="next-turn-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg" data-lang-key="next_turn_btn"></button>
        </div>
    </div>

    <div id="menu-container" class="hidden">
        <div class="relative">
            <button id="menu-btn" class="text-gray-600">
                <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
            </button>
            <div id="menu-dropdown" class="text-gray-800">
                <button id="restart-game-btn" data-lang-key="menuRestart"></button>
                <button id="toggle-fullscreen-btn" data-lang-key="menuFullscreen"></button>
                <button id="random-btn" data-lang-key="menuRandom"></button>
            </div>
        </div>
    </div>

    <div id="turn-indicator-container" class="hidden">
         <button id="turn-log-indicator" class="bg-gray-800 text-white text-xs font-bold w-8 h-8 rounded-full flex items-center justify-center border-2 border-white shadow-md">
            1
        </button>
    </div>

    <div id="random-result-box" class="hidden"></div>
    
        <!-- Simple Game Over Modal -->
        <div id="simple-gameover-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50">
            <div id="simple-gameover-modal-box" class="bg-white p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full">
                <p id="simple-gameover-message" class="text-3xl font-extrabold mb-10 leading-tight"></p>
                <button id="simple-gameover-close" class="py-4 px-10 text-xl bg-blue-500 hover:bg-blue-600 text-white font-semibold rounded-2xl transition-colors">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
            </div>
        </div>

    <div id="log-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-lg h-3/4 flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800" data-lang-key="logTitle">Game Log</h2>
                <button id="close-log-btn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            </div>
            <div id="log-content" class="flex-grow overflow-y-auto bg-gray-100 p-4 rounded-lg"></div>
        </div>
    </div>

    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full">
            <h2 id="confirm-modal-title" class="text-2xl font-bold text-gray-800 mb-4">Are you sure?</h2>
            <p id="confirm-modal-text" class="text-gray-600 mb-6">This action cannot be undone.</p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-cancel-btn" class="py-2 px-6 bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold rounded-xl transition-colors">Cancel</button>
                <button id="confirm-ok-btn" class="py-2 px-6 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-xl transition-colors">Confirm</button>
            </div>
        </div>
    </div>

    <p id="version-display" class="fixed bottom-2 right-3 text-xs text-gray-400 select-none z-10">version i1.3.0</p>

    <script>
        
        const STARTING_LIFE = { 2: 30, default: 60 };
        const CUSTOM_ORDERS = { 2: [1, 2], 3: [1, 2, 3], 4: [1, 2, 4, 3], 5: [1, 2, 3, 5, 4], 6: [1, 2, 3, 6, 5, 4] };
        const COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE = { 1: { left: 3, right: 2 }, 2: { left: 1, right: 4 }, 3: { left: 5, right: 1 }, 4: { left: 2, right: 6 }, 5: { left: 6, right: 3 }, 6: { left: 4, right: 5 } };
        
        const B_MODE_TURN_ORDERS = {
            '6B': [1, 3, 5, 6, 4, 2],
            '6C': [1, 2, 4, 6, 5, 3],
            '5B': [3, 5, 6, 4, 2],
            '5C': [3, 5, 6, 4, 2]
        };
        const COLOR_FAMILIES = [ [ { name: '‡πÅ‡∏î‡∏á', name_en: 'Red', tailwindClass: 'bg-red-600', textColorClass: 'text-red-600' }, { name: '‡∏Å‡∏∏‡∏´‡∏•‡∏≤‡∏ö', name_en: 'Rose', tailwindClass: 'bg-rose-500', textColorClass: 'text-rose-500' }, { name: '‡∏ä‡∏°‡∏û‡∏π', name_en: 'Pink', tailwindClass: 'bg-pink-500', textColorClass: 'text-pink-500' }, ], [ { name: '‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô', name_en: 'Blue', tailwindClass: 'bg-blue-600', textColorClass: 'text-blue-600' }, { name: '‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤', name_en: 'Sky', tailwindClass: 'bg-sky-500', textColorClass: 'text-sky-500' }, { name: '‡∏Ñ‡∏£‡∏≤‡∏°', name_en: 'Indigo', tailwindClass: 'bg-indigo-500', textColorClass: 'text-indigo-500' }, ], [ { name: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß', name_en: 'Green', tailwindClass: 'bg-green-600', textColorClass: 'text-green-600' }, { name: '‡∏°‡∏£‡∏Å‡∏ï', name_en: 'Emerald', tailwindClass: 'bg-emerald-500', textColorClass: 'text-emerald-500' }, { name: '‡∏ü‡πâ‡∏≤‡∏≠‡∏°‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß', name_en: 'Teal', tailwindClass: 'bg-teal-500', textColorClass: 'text-teal-500' }, { name: '‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏°‡∏∞‡∏ô‡∏≤‡∏ß', name_en: 'Lime', tailwindClass: 'bg-lime-500', textColorClass: 'text-lime-500' }, ], [ { name: '‡∏°‡πà‡∏ß‡∏á', name_en: 'Purple', tailwindClass: 'bg-purple-600', textColorClass: 'text-purple-600' }, { name: '‡πÑ‡∏ß‡πÇ‡∏≠‡πÄ‡∏•‡πá‡∏ï', name_en: 'Violet', tailwindClass: 'bg-violet-600', textColorClass: 'text-violet-600' }, ], [ { name: '‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á', name_en: 'Yellow', tailwindClass: 'bg-yellow-400', textColorClass: 'text-yellow-400' }, { name: '‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á‡∏≠‡∏≥‡∏û‡∏±‡∏ô', name_en: 'Amber', tailwindClass: 'bg-amber-500', textColorClass: 'text-amber-500' }, { name: '‡∏™‡πâ‡∏°', name_en: 'Orange', tailwindClass: 'bg-orange-500', textColorClass: 'text-orange-500' }, ], [ { name: '‡πÄ‡∏ó‡∏≤', name_en: 'Slate', tailwindClass: 'bg-slate-500', textColorClass: 'text-slate-500' },  ] ];
        const DEFEAT_TAUNTS = { th: [ "‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏à‡∏∏‡∏î‡∏≠‡πà‡∏≠‡∏ô!", "‡∏Å‡πä‡∏≤‡∏≤‡∏≤‡∏≤‡∏Å ‡∏Å ‡∏≤ ‡∏Å", "‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏Å‡∏∏‡∏®‡∏•", "‡∏™‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡πâ‡∏≤ 555", "‡πÅ‡∏Ñ‡πà‡∏ô‡∏µ‡πâ‡∏Å‡πá‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏î ‡∏™‡∏±‡∏™", "‡πÑ‡∏õ‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πä", "‡πÑ‡∏´‡∏ß‡∏õ‡πà‡∏∞‡πÄ‡∏ô‡∏µ‡πà‡∏¢?", "‡∏á‡πà‡∏ß‡∏á‡∏´‡∏£‡∏≤‡∏≤", "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏≠‡∏µ‡∏Å‡∏™‡∏±‡∏Å‡∏£‡πâ‡∏≠‡∏¢‡∏°‡∏∞?", "‡∏°‡∏±‡∏ô‡∏à‡πâ‡∏≤‡∏ã‡∏∞‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏ô!!", "‡πÑ‡∏≠‡πâ‡∏™‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡∏û‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÄ‡∏ñ‡∏≠‡∏∞", "‡∏ô‡∏¥‡πà‡∏°‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ ‡∏Ñ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏µ‡πâ‡∏ß‡∏∞!", "‡πÑ‡∏õ‡∏´‡∏ß‡∏±‡∏ô‡∏ã‡∏∞‡∏•‡∏∞", "‡∏£‡∏µ‡∏ö‡πÑ‡∏õ‡πÑ‡∏´‡∏ô ‡πÅ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡∏ã‡∏∑‡πâ‡∏≠‡∏ô‡πâ‡∏≥‡∏õ‡∏•‡∏≤‡πÄ‡∏´‡∏£‡∏≠", "‡∏≠‡∏∞‡πÄ‡∏´‡∏∑‡πâ‡∏≠!! ‡∏ù‡∏≤‡∏Å‡∏•‡∏π‡∏Å‡πÄ‡∏°‡∏µ‡∏¢‡∏Ç‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢", "‡πÑ‡∏ß‡πâ‡πÄ‡∏à‡∏≠‡∏Å‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏£‡πâ‡∏≤‡∏≤", "‡πÄ‡∏ò‡∏≠‡∏Ñ‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏´‡∏ô‡∏∂‡πà‡∏á...‡∏à‡∏≤‡∏Å‡∏ó‡πâ‡∏≤‡∏¢", "‡∏ô‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏≠‡∏≤‡∏Æ‡∏≤‡πÉ‡∏ä‡πà‡∏õ‡∏∞?", "R I P", "‡πÑ‡∏õ‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤ ‡∏î‡∏≥‡∏ô‡πâ‡∏≥ ‡∏î‡∏π‡∏õ‡∏∞‡∏Å‡∏≤‡∏£‡∏±‡∏á ‡∏Ø‡∏Ø", "‡πÑ‡∏õ‡∏ô‡∏±‡πà‡∏á‡∏™‡∏°‡∏≤‡∏ò‡∏¥‡∏£‡∏≠‡∏ô‡∏∞", "‡πÄ‡∏Å‡∏°‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô‡∏≠‡πà‡∏≠‡∏ô‡πÅ‡∏≠", "‡∏Ç‡∏≠‡∏ô‡πâ‡∏≥‡πÉ‡∏ö‡∏ö‡∏±‡∏ß‡∏ö‡∏Å‡∏´‡∏ô‡πà‡∏≠‡∏¢", "‡∏¢‡∏∑‡∏ô‡πÄ‡∏â‡∏¢‡πÜ ‡πÄ‡∏Ç‡∏≤‡∏Å‡πá‡∏ä‡∏ô‡∏∞", "‡∏Ñ‡πà‡∏≤‡∏à‡πâ‡∏≤‡∏á‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà‡πÄ‡∏ô‡∏µ‡πà‡∏¢?", "‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û", "‡∏ö‡∏ó‡∏ô‡πâ‡∏≠‡∏¢‡∏à‡∏±‡∏á‡∏ß‡∏∞", "‡∏ï‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏á‡∏ö ‡∏®‡∏û‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π", "‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡∏ï‡∏≤‡∏°‡∏ó‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á", "‡πÄ‡∏Å‡∏°‡∏û‡∏•‡∏¥‡∏Å‡∏ß‡πà‡∏∞...‡∏û‡∏•‡∏¥‡∏Å‡∏•‡∏á‡∏´‡∏•‡∏∏‡∏°" ], en: [ "Just a flesh wound.", "I've seen better plays in my soup.", "Were you trying?", "That was... an attempt.", "Error 404: Skill not found.", "Next time, try plugging in the controller.", "My grandma plays better.", "You're the reason for participation trophies.", "At least you tried. Or did you?", "I'm not mad, just disappointed.", "Task failed successfully.", "It's okay, we all have off-days.", "Maybe this isn't your game.", "A for effort, F for result.", "Did you lag?", "I'll send you a tutorial link.", "That's rough, buddy.", "You have been unsubscribed from life.", "GG EZ.", "Better luck next millennium." ] };
        const TRANSLATIONS = { 'th': { title: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏±‡∏ö Influence Crayne', appTitle: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏±‡∏ö Influence Crayne', playerCountLabel: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô:', startButton: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°', gameOverTitle: '‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß!', newGameButton: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà', ready: '‡∏û‡∏£‡πâ‡∏≠‡∏°', defeated: '‡πÅ‡∏û‡πâ‡πÅ‡∏•‡πâ‡∏ß', block: '‡∏ö‡∏•‡πá‡∏≠‡∏Å', winnerMsg: (c) => `‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ${c} ‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞!`, noWinnerMsg: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞!', menuRestart: '‡∏£‡∏µ‡∏™‡∏ï‡∏≤‡∏£‡πå‡∏ó', menuFullscreen: '‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠', menuExitFullscreen: '‡∏¢‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠', menuRandom: '‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç', next_turn_btn: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ', logTitle: '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏Å‡∏°', logTurn: (t) => `‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà ${t}` }, 'en': { title: 'Crayne Influence Counter', appTitle: 'Crayne Influence Counter', playerCountLabel: 'Players:', startButton: 'Start Game', gameOverTitle: 'Game Over!', newGameButton: 'New Game', ready: 'Ready', defeated: 'Defeated', block: 'Block', winnerMsg: (c) => `Player ${c} wins!`, noWinnerMsg: 'No Winner!', menuRestart: 'Restart', menuFullscreen: 'Fullscreen', menuExitFullscreen: 'Exit Fullscreen', menuRandom: 'Random', next_turn_btn: 'Next Turn', logTitle: 'Game Log', logTurn: (t) => `Turn ${t}` } };

        
        const gameState = {
            players: [],
            initialPlayerCount: 2,
            layoutMode: null,
            firstPlayerId: null,
            currentLang: 'en',
            isBuyPhase: false,
            turnCount: 0,
            gameLog: [],
            previousPlayerState: null,
            wakeLockSentinel: null,
            selectedColors: [],
            selectedFamilies: [],
            isGameOver: false,
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å menu
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            hasMoved: false,
            startX: 0,
            startY: 0
        };

        
        const ui = {
            playerCountSelector: document.getElementById('player-count'),
            playersContainer: document.getElementById('players-container'),
            startBtn: document.getElementById('start-btn'),
            setupControls: document.getElementById('setup-controls'),
              simpleGameOverModal: document.getElementById('simple-gameover-modal'),
              simpleGameOverMessage: document.getElementById('simple-gameover-message'),
              simpleGameOverClose: document.getElementById('simple-gameover-close'),
              languageSelector: document.getElementById('language-selector'),
              menuContainer: document.getElementById('menu-container'),
              menuBtn: document.getElementById('menu-btn'),
              menuDropdown: document.getElementById('menu-dropdown'),
              restartGameBtn: document.getElementById('restart-game-btn'),
              toggleFullscreenBtn: document.getElementById('toggle-fullscreen-btn'),
              randomBtn: document.getElementById('random-btn'),
              turnLogIndicator: document.getElementById('turn-log-indicator'),
              turnIndicatorContainer: document.getElementById('turn-indicator-container'),
              randomResultBox: document.getElementById('random-result-box'),
              versionDisplay: document.getElementById('version-display'),
              nextTurnContainer: document.getElementById('next-turn-container'),
              nextTurnBtn: document.getElementById('next-turn-btn'),
              undoBtn: document.getElementById('undo-btn'),
              logModal: document.getElementById('log-modal'),
              logContent: document.getElementById('log-content'),
              closeLogBtn: document.getElementById('close-log-btn'),
              colorSelectPanel: document.getElementById('color-select-panel'),
              confirmModal: document.getElementById('confirm-modal'),
              confirmOkBtn: document.getElementById('confirm-ok-btn'),
              confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
              iphoneSafeAreaToggle: document.getElementById('iphone-safearea-toggle')
        };
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î iPhone mode ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö iOS
        function updateSafeAreaPadding() {
            const body = document.body;
            const setupControls = document.getElementById('setup-controls');
            const playersContainer = document.getElementById('players-container');
            const modals = [
                document.getElementById('simple-gameover-modal'),
                document.getElementById('log-modal'),
                document.getElementById('confirm-modal')
            ];
            
            if (ui.iphoneSafeAreaToggle && ui.iphoneSafeAreaToggle.checked) {
                // ‡πÄ‡∏õ‡∏¥‡∏î iPhone mode
                body.classList.add('iphone-mode-container');
                if (setupControls) setupControls.classList.add('iphone-mode');
                if (playersContainer) playersContainer.classList.add('iphone-mode');
                modals.forEach(modal => { if (modal) modal.classList.add('iphone-mode'); });
            } else {
                // ‡∏õ‡∏¥‡∏î iPhone mode
                body.classList.remove('iphone-mode-container');
                if (setupControls) setupControls.classList.remove('iphone-mode');
                if (playersContainer) playersContainer.classList.remove('iphone-mode');
                modals.forEach(modal => { if (modal) modal.classList.remove('iphone-mode'); });
            }
        }

        
        const shuffleArray = (array) => { const newArr = [...array]; for (let i = newArr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newArr[i], newArr[j]] = [newArr[j], newArr[i]]; } return newArr; };
        const goFullscreen = (orientation = 'landscape') => { const el = document.documentElement; if (el.requestFullscreen) el.requestFullscreen(); else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); if (screen.orientation && screen.orientation.lock) screen.orientation.lock(orientation).catch(() => {}); };
        const getPlayerCountFromLayout = (layout) => parseInt(layout) || 0;

        const manageWakeLock = async (enable) => {
            if ('wakeLock' in navigator) {
                if (enable && !gameState.wakeLockSentinel) {
                    try {
                        gameState.wakeLockSentinel = await navigator.wakeLock.request('screen');
                        console.log('Screen Wake Lock is active.');
                        gameState.wakeLockSentinel.addEventListener('release', () => {
                            console.log('Screen Wake Lock was released by the system.');
                            gameState.wakeLockSentinel = null;
                        });
                    } catch (err) {
                        console.error(`Wake Lock failed: ${err.name}, ${err.message}`);
                    }
                } else if (!enable && gameState.wakeLockSentinel) {
                    await gameState.wakeLockSentinel.release();
                    gameState.wakeLockSentinel = null;
                    console.log('Screen Wake Lock released.');
                }
            } else {
                console.log('Wake Lock API is not supported by this browser.');
            }
        };

        
        function renderColorSelectPanel() {
            const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
            
            const allColors = COLOR_FAMILIES.flat().filter(color =>
            
                !(
                    (color.name_en === 'Violet') ||
                    (color.name_en === 'Teal')
                )
            );
            if (!Array.isArray(gameState.selectedColors)) gameState.selectedColors = [];
            if (gameState.selectedColors.length > count) gameState.selectedColors = gameState.selectedColors.slice(0, count);
            ui.colorSelectPanel.innerHTML = allColors.map(color => {
                const isSelected = gameState.selectedColors.some(sel => sel.name_en === color.name_en);
                return `<button type="button" class="w-8 h-8 rounded-full border-2 ${color.tailwindClass} ${isSelected ? 'ring-4 ring-blue-400' : 'ring-2 ring-gray-200'} transition-all" data-color="${color.name_en}" title="${color.name_en}"></button>`;
            }).join('');
            const selectedCount = gameState.selectedColors.length;
            ui.colorSelectPanel.querySelectorAll('button').forEach(btn => {
                const colorName = btn.getAttribute('data-color');
                if (!gameState.selectedColors.some(sel => sel.name_en === colorName) && selectedCount >= count) {
                    btn.disabled = true;
                    btn.classList.add('opacity-40', 'cursor-not-allowed');
                } else {
                    btn.disabled = false;
                    btn.classList.remove('opacity-40', 'cursor-not-allowed');
                }
            });
        }

        ui.colorSelectPanel.addEventListener('click', function(e) {
            if (e.target.tagName !== 'BUTTON') return;
            const colorName = e.target.getAttribute('data-color');
            
            const allColors = COLOR_FAMILIES.flat().filter(color =>
                !(color.name_en === 'Violet' || color.name_en === 'Teal')
            );
            const colorObj = allColors.find(c => c.name_en === colorName);
            if (!colorObj) return;
            const idx = gameState.selectedColors.findIndex(c => c.name_en === colorName);
            if (idx >= 0) {
                gameState.selectedColors.splice(idx, 1);
            } else {
                const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
                if (gameState.selectedColors.length < count) {
                    gameState.selectedColors.push(colorObj);
                }
            }
            renderColorSelectPanel();
        });

        function updateColorSelectOnPlayerCountChange() {
            const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
            if (gameState.selectedColors.length > count) {
                gameState.selectedColors = gameState.selectedColors.slice(0, count);
            }
            renderColorSelectPanel();
        }

        
        // ===== LAYOUT CONFIGURATION =====
        const LAYOUT_CONFIG = {
            // Standard layouts (2-6 players)
            '2': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'  // Top half rotated 180deg
            },
            '3': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotations: { 1: 'rotate-180' }  // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 1 ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏±‡∏ß
            },
            '4': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            '5': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            '6': { 
                type: 'standard', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            
            // B Mode layouts
            '3B': { 
                type: 'compact', cssClass: '', needsRotation: true,
                rotationRule: 'top-half'
            },
            '5B': { 
                type: 'compact', cssClass: 'layout-5p', needsRotation: true,
                gridPositions: { 2: 'col-start-1 row-start-1', 3: 'col-start-2 row-start-1', 4: 'col-start-1 row-start-2', 5: 'col-start-2 row-start-2', 6: 'col-span-2 row-start-3' },
                rotations: { 2: 'rotate-90', 3: '-rotate-90', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '5C': { 
                type: 'compact', cssClass: 'layout-5p', needsRotation: true,
                gridPositions: { 2: 'col-start-1 row-start-1', 3: 'col-start-2 row-start-1', 4: 'col-start-1 row-start-2', 5: 'col-start-2 row-start-2', 6: 'col-span-2 row-start-3' },
                rotations: { 2: 'rotate-180', 3: 'rotate-180', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '6B': { 
                type: 'compact', cssClass: 'layout-6b', needsRotation: true,
                gridPositions: { 1: 'col-span-2 row-start-1', 2: 'col-start-1 row-start-2', 3: 'col-start-2 row-start-2', 4: 'col-start-1 row-start-3', 5: 'col-start-2 row-start-3', 6: 'col-span-2 row-start-4' },
                rotations: { 1: 'rotate-180', 2: 'rotate-90', 3: '-rotate-90', 4: 'rotate-90', 5: '-rotate-90' }
            },
            '6C': { 
                type: 'compact', cssClass: '', needsRotation: true,
                gridPositions: { 1: 'col-start-1 row-start-1', 2: 'col-start-2 row-start-1', 3: 'col-start-1 row-start-2', 4: 'col-start-2 row-start-2', 5: 'col-start-1 row-start-3', 6: 'col-start-2 row-start-3' },
                rotations: { 1: 'rotate-180', 2: 'rotate-180', 3: 'rotate-90', 4: '-rotate-90', 5: '', 6: '' }
            }
        };

        const getFontSizes = (layoutMode, playerCount) => {
            const isTwoPlayerMode = playerCount === 2;
            const isCompactMode = LAYOUT_CONFIG[layoutMode]?.type === 'compact';
            
            if (isCompactMode) {
                // Compact modes use larger sizes for better balance
                return {
                    stats: 'text-5xl', block: 'text-2xl', label: 'text-sm',
                    smallBtn: 'w-6 h-6', mediumBtn: 'w-7 h-7', largeBtn: 'w-10 h-10 text-2xl'
                };
            } else {
                // Standard modes with responsive sizing
                const base = {
                    stats: 'text-3xl sm:text-4xl md:text-5xl font-bold',
                    block: 'text-2xl sm:text-3xl font-bold',
                    label: 'text-sm', readyBtn: 'p-3 text-base',
                    smallBtn: 'w-6 h-6 sm:w-7 sm:h-7',
                    mediumBtn: 'w-8 h-8 sm:w-9 sm:h-9',
                    largeBtn: 'w-10 h-10 sm:w-12 sm:h-12 text-2xl'
                };
                
                if (isTwoPlayerMode) {
                    return Object.assign(base, {
                        stats: 'text-6xl font-bold', block: 'text-4xl font-bold',
                        label: 'text-lg', readyBtn: 'p-3 text-lg',
                        smallBtn: 'w-8 h-8', mediumBtn: 'w-10 h-10',
                        largeBtn: 'w-10 h-10 text-3xl'
                    });
                }
                return base;
            }
        };

        const renderAllCards = () => {
            gameState.players.forEach(p => {
                if (!p.isInitiallyDefeated) updatePlayerCard(p);
            });
        };

        const createPlayerCardHTML = (player, layoutMode) => {
            const config = LAYOUT_CONFIG[layoutMode];
            const fontSizes = getFontSizes(layoutMode, gameState.initialPlayerCount);
            
            if (config?.type === 'compact') {
                // Compact layout (B/C modes)
                return `
                    <div class="relative w-full h-full flex items-center justify-center text-white p-1 overflow-hidden">
                        <div class="dual-block-ui absolute top-4 left-0 right-0 flex justify-around items-center z-20">
                            ${createBlockControl(player.id, 'leftBlock')}
                            ${createReadyButton(player.id)}
                            ${createBlockControl(player.id, 'rightBlock')}
                        </div>
                        <div class="single-block-ui hidden absolute top-4 left-0 right-0 flex justify-around items-center z-20">
                            ${createBlockControl(player.id, 'block')}
                            ${createReadyButton(player.id)}
                        </div>
                        <div class="flex items-center justify-center space-x-2 z-10 mt-2">
                            <button data-player-id="${player.id}" data-action="decrement-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-red-500 bg-opacity-80 rounded-full">-</button>
                            <div class="relative flex items-center justify-center">
                                <div class="damage-container absolute left-0 -translate-x-full pr-2"></div>
                                <span class="life-display font-extrabold text-white text-6xl mx-2">60</span>
                            </div>
                            <button data-player-id="${player.id}" data-action="increment-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-green-500 bg-opacity-80 rounded-full">+</button>
                        </div>
                        <div class="absolute bottom-4 left-0 right-0 flex justify-center items-center gap-4 z-10">
                            ${createStatControl('atk', '‚öîÔ∏è', player.id, fontSizes)}
                            ${createReadyButton(player.id)}
                            ${createStatControl('def', 'üõ°Ô∏è', player.id, fontSizes)}
                        </div>
                    </div>`;
            } else {
                // Standard layout (2-6 players)
                return `<div class="relative p-2 flex flex-col items-center justify-between h-full">
                    <div class="absolute inset-0 flex items-center justify-center pointer-events-none z-0"><span class="life-display font-extrabold text-white">60</span></div>
                    <div class="relative z-10 w-full flex items-center justify-between">
                        <!-- DUAL BLOCK UI -->
                        <div class="dual-block-ui w-full flex items-center justify-between">
                            <div class="flex flex-col items-center flex-1"><div class="flex items-center"><span class="${fontSizes.label}" data-lang-key="block"></span><div class="left-opponent-indicator w-3 h-3 ml-1 rounded-full ring-2 ring-white"></div></div><div class="flex items-center mt-1"><button data-player-id="${player.id}" data-action="decrement-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">-</button><span class="left-block-display ${fontSizes.block}">0</span><button data-player-id="${player.id}" data-action="increment-leftBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">+</button></div></div>
                            <div class="flex-shrink-0"><button data-player-id="${player.id}" data-action="ready" class="ready-btn bg-white text-gray-800 font-semibold shadow-lg" title="Ready">‚öîÔ∏è</button></div>
                            <div class="flex flex-col items-center flex-1"><div class="flex items-center"><span class="${fontSizes.label}" data-lang-key="block"></span><div class="right-opponent-indicator w-3 h-3 ml-1 rounded-full ring-2 ring-white"></div></div><div class="flex items-center mt-1"><button data-player-id="${player.id}" data-action="decrement-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">-</button><span class="right-block-display ${fontSizes.block}">0</span><button data-player-id="${player.id}" data-action="increment-rightBlock" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">+</button></div></div>
                        </div>
                        <!-- SINGLE BLOCK UI -->
                        <div class="single-block-ui hidden w-full flex items-center justify-between">
                            <div class="flex-1"></div>
                            <div class="flex flex-col items-center flex-1"><span class="${fontSizes.label}" data-lang-key="block"></span><div class="flex items-center mt-1"><button data-player-id="${player.id}" data-action="decrement-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">-</button><span class="block-display ${fontSizes.block}">0</span><button data-player-id="${player.id}" data-action="increment-block" class="${fontSizes.smallBtn} bg-white bg-opacity-30 rounded-full">+</button></div></div>
                            <div class="flex-1 flex justify-center"><button data-player-id="${player.id}" data-action="ready" class="ready-btn bg-white text-gray-800 font-semibold shadow-lg" title="Ready">‚öîÔ∏è</button></div>
                        </div>
                    </div>
                    <div class="relative z-10 flex-grow w-full flex items-center justify-between px-2"><button data-player-id="${player.id}" data-action="decrement-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-red-500 bg-opacity-80 rounded-full">-</button><button data-player-id="${player.id}" data-action="increment-life" class="${fontSizes.largeBtn} flex items-center justify-center bg-green-500 bg-opacity-80 rounded-full">+</button></div>
                    <div class="relative z-10 flex justify-center items-center gap-4 w-full">${createStatControl('atk', '‚öîÔ∏è', player.id, fontSizes)}<div class="damage-container w-24"></div>${createStatControl('def', 'üõ°Ô∏è', player.id, fontSizes)}</div>
                </div>`;
            }
        };

        const createPlayerCard = (player) => {
            const playerCard = document.createElement('div');
            playerCard.id = `player-card-${player.id}`;
            const contentHTML = createPlayerCardHTML(player, gameState.layoutMode);
            playerCard.innerHTML = `<div class="content-wrapper">${contentHTML}<div class="defeated-overlay" style="display: none;"><span class="text-2xl font-extrabold" data-lang-key="defeated"></span><span class="taunt-text text-lg italic mt-2 text-red-300"></span></div></div>`;
            return playerCard;
        };
        
        // ===== HTML HELPERS - CONSOLIDATED =====
        const createStatControl = (type, label, playerId, fontSizes) => 
            `<div class="flex flex-col items-center relative">
                <div class="relative">
                    <div class="text-6xl opacity-20 absolute inset-0 flex items-center justify-center pointer-events-none">${label}</div>
                    <div class="flex items-center gap-3 relative z-10">
                        <button data-player-id="${playerId}" data-action="decrement-${type}" class="${fontSizes.mediumBtn || 'w-8 h-8'} bg-white bg-opacity-30 rounded-full text-lg font-bold hover:bg-opacity-50 active:scale-95 transition-all">-</button>
                        <span class="${type}-display ${fontSizes.stats || 'text-4xl'} font-bold text-white" style="text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;">00</span>
                        <button data-player-id="${playerId}" data-action="increment-${type}" class="${fontSizes.mediumBtn || 'w-8 h-8'} bg-white bg-opacity-30 rounded-full text-lg font-bold hover:bg-opacity-50 active:scale-95 transition-all">+</button>
                    </div>
                </div>
            </div>`;
        const createBlockControl = (playerId, type, size = 'w-6 h-6', textSize = 'text-2xl') => 
            `<div class="flex flex-col items-center">
                <span class="text-sm font-semibold opacity-80 mb-1">BLOCK</span>
                <div class="flex items-center gap-2">
                    <button data-player-id="${playerId}" data-action="decrement-${type}" class="${size} bg-white bg-opacity-30 rounded-full text-lg font-bold hover:bg-opacity-50 active:scale-95 transition-all">-</button>
                    <span class="${type}-display ${textSize} font-bold mx-2 text-white" style="text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;">00</span>
                    <button data-player-id="${playerId}" data-action="increment-${type}" class="${size} bg-white bg-opacity-30 rounded-full text-lg font-bold hover:bg-opacity-50 active:scale-95 transition-all">+</button>
                </div>
            </div>`;
        const createReadyButton = (playerId) => 
            `<button data-player-id="${playerId}" data-action="ready" class="ready-btn bg-white text-gray-800 font-semibold shadow-lg" title="Ready">‚öîÔ∏è</button>`;


        
        const updatePlayerCard = (player) => {
            const card = document.getElementById(`player-card-${player.id}`);
            if (!card) return;
            _updateBlockVisibility(card);
            _updateCardLayout(card, player);
            _updateCardState(card, player);
            _updateCardData(card, player);
            _updateOpponentIndicators(card, player);
            _updateCardControls(card, player);
        };

        const _updateBlockVisibility = (card) => {
            const activePlayersCount = gameState.players.filter(p => !p.isDefeated).length;
            const singleBlockUI = card.querySelector('.single-block-ui');
            const dualBlockUI = card.querySelector('.dual-block-ui');
            if (!singleBlockUI || !dualBlockUI) return;
            const showSingle = activePlayersCount <= 2;
            singleBlockUI.classList.toggle('hidden', !showSingle);
            dualBlockUI.classList.toggle('hidden', showSingle);
        };

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏±‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏´‡∏•‡∏±‡∏á‡∏´‡∏°‡∏∏‡∏ô (‡∏ß‡∏¥‡∏ò‡∏µ C - ‡∏ß‡∏±‡∏î‡∏Ç‡∏≠‡∏ö‡∏ï‡∏£‡∏á‡πÜ)
        const adjustCardAspectRatio = (card, rotation) => {
            const contentWrapper = card.querySelector('.content-wrapper');
            if (!contentWrapper) return;

            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï rotation ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á
            const currentTransform = contentWrapper.style.transform;
            contentWrapper.style.transform = '';
            
            // ‡∏ß‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏à‡∏≤‡∏Å card container (‡∏ó‡∏µ‡πà‡∏°‡∏µ background ‡∏à‡∏£‡∏¥‡∏á‡πÜ)
            const rect = card.getBoundingClientRect();
            const originalWidth = rect.width;
            const originalHeight = rect.height;
            
            // ‡∏Ñ‡∏∑‡∏ô rotation ‡∏Å‡∏•‡∏±‡∏ö
            contentWrapper.style.transform = currentTransform;

            // ‡∏´‡∏≤‡∏Å‡∏´‡∏°‡∏∏‡∏ô 90¬∞ ‡∏´‡∏£‡∏∑‡∏≠ -90¬∞ ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î  
            if (rotation && rotation.includes('90')) {
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
                // ‡πÉ‡∏ä‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏£‡∏≠‡∏ö ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏¢‡πà‡∏≠‡∏°‡∏≤‡∏Å
                const minDimension = Math.min(originalWidth, originalHeight);
                const scaleFactor = 0.98; // ‡∏¢‡πà‡∏≠‡πÅ‡∏Ñ‡πà 2% ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
                
                const newWidth = minDimension * scaleFactor;
                const newHeight = minDimension * scaleFactor;
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì offset ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏≤‡∏á
                const offsetX = (originalWidth - newWidth) / 2;
                const offsetY = (originalHeight - newHeight) / 2;
                
                // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ CSS variables
                contentWrapper.style.setProperty('--card-width', `${newWidth}px`);
                contentWrapper.style.setProperty('--card-height', `${newHeight}px`);
                contentWrapper.style.setProperty('--offset-x', `${offsetX}px`);
                contentWrapper.style.setProperty('--offset-y', `${offsetY}px`);
                
                contentWrapper.classList.add('rotation-adjusted');
                
                console.log(`Card ${card.id}: Rotated ${originalWidth}x${originalHeight} -> ${newWidth}x${newHeight}, offset: ${offsetX},${offsetY}`);
            } else {
                // ‡πÑ‡∏°‡πà‡∏´‡∏°‡∏∏‡∏ô 90¬∞ ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏•‡∏±‡∏ö
                contentWrapper.style.removeProperty('--card-width');
                contentWrapper.style.removeProperty('--card-height');
                contentWrapper.style.removeProperty('--offset-x');
                contentWrapper.style.removeProperty('--offset-y');
                contentWrapper.classList.remove('rotation-adjusted');
            }
        };

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        const recalculateAllCards = () => {
            console.log('Recalculating all card sizes...');
            gameState.players.forEach(player => {
                const card = document.getElementById(`player-card-${player.id}`);
                if (card) {
                    // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ DOM update ‡πÄ‡∏™‡∏£‡πá‡∏à
                    setTimeout(() => {
                        const contentWrapper = card.querySelector('.content-wrapper');
                        if (contentWrapper) {
                            const rotation = contentWrapper.style.transform.includes('rotate') 
                                ? contentWrapper.style.transform.match(/rotate\(([^)]+)\)/)?.[1] 
                                : '';
                            adjustCardAspectRatio(card, rotation);
                        }
                    }, 100);
                }
            });
        };

        const _updateCardLayout = (card, player) => {
            let baseClasses = `${player.tailwindClass} text-white shadow-xl relative overflow-hidden flex`;
            const config = LAYOUT_CONFIG[gameState.layoutMode];
            const contentWrapper = card.querySelector('.content-wrapper');
            
            // Get grid position from config
            let gridPosition = config?.gridPositions?.[player.id] || '';
            
            // Get rotation from config
            let rotation = '';
            if (config?.rotations) {
                // Use specific rotations from config
                rotation = config.rotations[player.id] || '';
            } else if (config?.rotationRule === 'top-half') {
                // Use top-half rotation rule
                const playerCount = getPlayerCountFromLayout(gameState.layoutMode);
                rotation = (playerCount === 2 ? player.id === 1 : player.id <= Math.ceil(playerCount / 2)) ? 'rotate-180' : '';
            }

            card.className = `${baseClasses} ${gridPosition}`;
            contentWrapper.style.transform = rotation ? `rotate(${rotation.replace('rotate-', '')}deg)` : '';
            
            // Apply layout-specific CSS classes from config
            if (config?.cssClass) {
                contentWrapper.classList.add(config.cssClass);
            }
            contentWrapper.classList.toggle('is-rotated-sideways', rotation.includes('90'));
            
            // ‡∏ß‡∏±‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö aspect ratio ‡∏´‡∏•‡∏±‡∏á‡∏´‡∏°‡∏∏‡∏ô (‡∏ß‡∏¥‡∏ò‡∏µ B)
            setTimeout(() => adjustCardAspectRatio(card, rotation), 100);
        };

        const _updateCardState = (card, player) => {
            const defeatedOverlay = card.querySelector('.defeated-overlay');
            if (player.isDefeated) {
                card.classList.add('opacity-40');
                defeatedOverlay.style.display = 'flex';
                defeatedOverlay.querySelector('.taunt-text').textContent = player.defeatTaunt || '';
            } else {
                card.classList.remove('opacity-40');
                defeatedOverlay.style.display = 'none';
            }
        };

        const _updateCardData = (card, player) => {
            card.querySelector('.life-display').textContent = player.life;
            card.querySelector('.life-display').classList.toggle('first-player-highlight', player.id === gameState.firstPlayerId && !player.isDefeated);
            card.querySelector('.atk-display').textContent = player.atk;
            card.querySelector('.def-display').textContent = player.def;
            const blockDisplay = card.querySelector('.block-display');
            if (blockDisplay) blockDisplay.textContent = player.block;
            const leftBlockDisplay = card.querySelector('.left-block-display');
            if(leftBlockDisplay) leftBlockDisplay.textContent = player.leftBlock;
            const rightBlockDisplay = card.querySelector('.right-block-display');
            if(rightBlockDisplay) rightBlockDisplay.textContent = player.rightBlock;
            const damageContainer = card.querySelector('.damage-container');
            const damageFontSize = ['6B', '6C', '5B', '5C', '3B'].includes(gameState.layoutMode) ? 'text-5xl' : 'text-4xl';
            damageContainer.innerHTML = (player.lastDamageTaken > 0 && gameState.isBuyPhase) ? `<span class="damage-display ${damageFontSize} font-bold">-${player.lastDamageTaken}</span>` : '';
        };

        const _updateOpponentIndicators = (card, player) => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length <= 2) {
                const leftIndicator = card.querySelector('.left-opponent-indicator');
                if (leftIndicator) leftIndicator.classList.add('hidden');
                const rightIndicator = card.querySelector('.right-opponent-indicator');
                if (rightIndicator) rightIndicator.classList.add('hidden');
                return;
            };

            const leftIndicator = card.querySelector('.left-opponent-indicator');
            if(leftIndicator) leftIndicator.classList.remove('hidden');
            const rightIndicator = card.querySelector('.right-opponent-indicator');
            if(rightIndicator) rightIndicator.classList.remove('hidden');

            let leftOpponent, rightOpponent;
            const config = LAYOUT_CONFIG[gameState.layoutMode];
            const isCompactMode = config?.type === 'compact';

            if (isCompactMode && gameState.layoutMode !== '6C') {
                const activePlayerIds = activePlayers.map(p => p.id);
                const actualLeftOpponentId = get6BActualOpponent(player.id, COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[player.id].left, activePlayerIds);
                const actualRightOpponentId = get6BActualOpponent(player.id, COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[player.id].right, activePlayerIds);
                leftOpponent = gameState.players.find(p => p.id === actualLeftOpponentId);
                rightOpponent = gameState.players.find(p => p.id === actualRightOpponentId);
            } else if (gameState.layoutMode === '6C') {
                // 6C mode: ‡πÉ‡∏ä‡πâ turn order ‡∏û‡∏¥‡πÄ‡∏®‡∏© 1‚Üí2‚Üí4‚Üí6‚Üí5‚Üí3
                const activePlayerOrder = B_MODE_TURN_ORDERS['6C'].filter(id => activePlayers.some(p => p.id === id));
                const currentPlayerIndex = activePlayerOrder.indexOf(player.id);
                if (currentPlayerIndex !== -1) {
                    leftOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex + 1) % activePlayerOrder.length]);
                    rightOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                }
            } else {
                const activePlayerOrder = CUSTOM_ORDERS[getPlayerCountFromLayout(gameState.layoutMode)].filter(id => activePlayers.some(p => p.id === id));
                const currentPlayerIndex = activePlayerOrder.indexOf(player.id);
                if (currentPlayerIndex === -1) return;
                leftOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex + 1) % activePlayerOrder.length]);
                rightOpponent = gameState.players.find(p => p.id === activePlayerOrder[(currentPlayerIndex - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
            }
            
            if (leftIndicator) leftIndicator.className = `left-opponent-indicator w-3 h-3 ml-1 rounded-full ring-2 ring-white ${leftOpponent ? leftOpponent.tailwindClass : 'bg-transparent'}`;
            if (rightIndicator) rightIndicator.className = `right-opponent-indicator w-3 h-3 ml-1 rounded-full ring-2 ring-white ${rightOpponent ? rightOpponent.tailwindClass : 'bg-transparent'}`;
        };

        const _updateCardControls = (card, player) => {
            card.querySelectorAll('.ready-btn').forEach(readyBtn => {
                if(readyBtn) {
                    // ‡πÉ‡∏ä‡πâ‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô‡∏î‡∏≤‡∏ö‡πÄ‡∏™‡∏°‡∏≠ ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
                    readyBtn.textContent = '‚öîÔ∏è';
                    readyBtn.classList.toggle('bg-green-500', player.isReady);
                    readyBtn.classList.toggle('text-white', player.isReady);
                    readyBtn.classList.toggle('bg-white', !player.isReady);
                    readyBtn.classList.toggle('text-gray-800', !player.isReady);
                    readyBtn.disabled = player.isDefeated || gameState.isBuyPhase;
                }
            });
            const shouldLock = player.isDefeated || player.isReady || gameState.isBuyPhase;
            card.querySelectorAll(`[data-action$="-atk"], [data-action$="-def"], [data-action*="Block"]`).forEach(btn => btn.disabled = shouldLock);
            card.querySelectorAll(`[data-action$="-life"]`).forEach(btn => btn.disabled = player.isDefeated);
        };

        const showLifeChangeIndicator = (playerId, totalChange) => {
            const card = document.getElementById(`player-card-${playerId}`);
            if (!card || totalChange === 0) return;
            let indicator = card.querySelector('.life-change-indicator');
            if (indicator) indicator.remove();
            indicator = document.createElement('div');
            indicator.className = 'life-change-indicator';
            indicator.textContent = `${totalChange > 0 ? '+' : ''}${totalChange}`;
            indicator.style.color = totalChange > 0 ? '#a7f3d0' : '#fecaca';
            const contentWrapper = card.querySelector('.content-wrapper > div');
            if (contentWrapper) {
                contentWrapper.appendChild(indicator);
                setTimeout(() => indicator.remove(), 1400);
            }
        };

        const setLanguage = (lang) => {
            gameState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                const translation = TRANSLATIONS[lang][key];
                if (translation && typeof translation === 'string') {
                    el.textContent = translation;
                }
            });
            // Update modal button text
            if (ui.simpleGameOverClose) {
                ui.simpleGameOverClose.textContent = TRANSLATIONS[lang].newGameButton || 'New Game';
            }
            if (gameState.players.length > 0) renderAllCards();
        };
        
        // ===== UTILITY FUNCTIONS - CONSOLIDATED =====
        const logEvent = (message) => gameState.gameLog.push(message);
        const updateLogModal = () => { 
            ui.logContent.innerHTML = gameState.gameLog.map(entry => `<p class="text-sm text-gray-600 mb-1">${entry}</p>`).join(''); 
            ui.logContent.scrollTop = ui.logContent.scrollHeight; 
        };
        const updateControlPositions = () => {
            const moveControls = ['3B', '5B', '5C', '6C'].includes(gameState.layoutMode);
            ui.menuContainer.classList.toggle('bottom-center', moveControls);
            ui.turnIndicatorContainer.classList.toggle('top-center', moveControls);
        };
        const resetPlayerTurnStats = () => gameState.players.forEach(p => { 
            if (!p.isDefeated) Object.assign(p, { atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0 }); 
        });
        const checkAllReady = () => { 
            const activePlayers = gameState.players.filter(p => !p.isDefeated); 
            if (activePlayers.length > 0 && activePlayers.every(p => p.isReady)) handleRoundEnd(); 
        };

        const startGame = () => {
            gameState.layoutMode = ui.playerCountSelector.value;
            gameState.initialPlayerCount = getPlayerCountFromLayout(gameState.layoutMode);
            if (gameState.selectedColors.length !== gameState.initialPlayerCount) {
                alert('Please select exactly ' + gameState.initialPlayerCount + ' colors.');
                return;
            }
            initPlayers();
            updateControlPositions();
            ui.setupControls.classList.add('hidden');
            ui.menuContainer.classList.remove('hidden');
            ui.turnIndicatorContainer.classList.remove('hidden');
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
            setTimeout(() => recalculateAllCards(), 200);
        };

        const resetGame = () => {
            Object.assign(gameState, { players: [], initialPlayerCount: 0, layoutMode: null, firstPlayerId: null, isBuyPhase: false, turnCount: 0, gameLog: [], previewColors: [], previousPlayerState: null });
            updateControlPositions(); // Reset positions on game reset
            ui.nextTurnContainer.classList.add('hidden');
            ui.playersContainer.innerHTML = '';
            ui.setupControls.classList.remove('hidden');
            ui.menuContainer.classList.add('hidden');
            ui.turnIndicatorContainer.classList.add('hidden');
            if (document.fullscreenElement) document.exitFullscreen();
            updateColorPreview();
            setLanguage(gameState.currentLang);
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á reset
            setTimeout(() => recalculateAllCards(), 200);
        };
        
        const initPlayers = () => {
            const isBMode = ['6B', '5B', '5C'].includes(gameState.layoutMode);
            let gameColors = [];
            let playerIds = [];
            if (gameState.layoutMode === '5B' || gameState.layoutMode === '5C') {
                
                gameColors = shuffleArray([...gameState.selectedColors]);
                playerIds = [2,3,4,5,6];
                
                gameState.players = [
                    {
                        id: 1,
                        ...COLOR_FAMILIES[0][0], // ‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÑ‡∏°‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
                        life: 0,
                        isDefeated: true,
                        isInitiallyDefeated: true,
                        atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0, defeatTaunt: null
                    },
                    ...playerIds.map((id, idx) => ({
                        id,
                        ...gameColors[idx],
                        life: STARTING_LIFE.default,
                        isDefeated: false,
                        isInitiallyDefeated: false,
                        atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0, defeatTaunt: null
                    }))
                ];
            } else if (isBMode) {
                
                const selected = shuffleArray([...gameState.selectedColors]);
                const allColors = COLOR_FAMILIES.map(family => family[0]);
                while (selected.length < 6) {
                    const unused = allColors.filter(c => !selected.some(sel => sel.name_en === c.name_en));
                    if (unused.length === 0) break;
                    selected.push(unused[Math.floor(Math.random() * unused.length)]);
                }
                gameColors = selected.slice(0, 6);
                gameState.players = Array.from({ length: 6 }, (_, i) => ({
                    id: i + 1,
                    ...gameColors[i],
                    life: STARTING_LIFE.default,
                    isDefeated: false,
                    isInitiallyDefeated: false,
                    atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0, defeatTaunt: null
                }));
            } else {
                gameColors = shuffleArray([...gameState.selectedColors]);
                gameState.players = Array.from({ length: gameState.initialPlayerCount }, (_, i) => ({
                    id: i + 1,
                    ...gameColors[i],
                    life: STARTING_LIFE.default,
                    isDefeated: false,
                    isInitiallyDefeated: false,
                    atk: 0, def: 0, leftBlock: 0, rightBlock: 0, block: 0, isReady: false, lastDamageTaken: 0, manualLifeChange: 0, defeatTaunt: null
                }));
            }
            if (gameState.initialPlayerCount === 2) gameState.players.forEach(p => p.life = STARTING_LIFE[2]);
            
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length > 0) gameState.firstPlayerId = activePlayers[Math.floor(Math.random() * activePlayers.length)].id;
            gameState.turnCount = 1;
            ui.turnLogIndicator.textContent = gameState.turnCount;
            gameState.gameLog = [];
            logEvent(`<strong>Game Started with ${activePlayers.length} players (Mode: ${gameState.layoutMode}).</strong>`);
            logEvent(`<strong>--- ${TRANSLATIONS[gameState.currentLang].logTurn(gameState.turnCount)} ---</strong>`);
            
            ui.playersContainer.innerHTML = '';
            ui.playersContainer.style.gridTemplateRows = '';
            ui.playersContainer.className = 'w-full h-full flex-grow grid min-h-0';

            if (gameState.layoutMode === '6B') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-4');
                ui.playersContainer.style.gridTemplateRows = '1fr 1.5fr 1.5fr 1fr';
            } else if (gameState.layoutMode === '6C') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-3');
                ui.playersContainer.style.gridTemplateRows = '1fr 1fr 1fr';
            } else if (gameState.layoutMode === '5B' || gameState.layoutMode === '5C') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-3');
                ui.playersContainer.style.gridTemplateRows = '1.3fr 1.3fr 1.4fr';
            } else if (gameState.layoutMode === '3v') {
                ui.playersContainer.classList.add('grid-cols-2', 'grid-rows-2');
                ui.playersContainer.style.gridTemplateRows = '1fr 1fr';
            } else {
                let gridClass = 'grid-cols-2';
                if (gameState.initialPlayerCount <= 2) gridClass = 'grid-cols-1';
                if (gameState.initialPlayerCount === 3) gridClass = 'grid-cols-2';
                if (gameState.initialPlayerCount >= 5) gridClass = 'grid-cols-2 md:grid-cols-3';
                ui.playersContainer.classList.add(...gridClass.split(' '));
            }

            
            let playersToRender = gameState.players.filter(p => !p.isInitiallyDefeated);
            if (gameState.layoutMode === '5B' || gameState.layoutMode === '5C') {
                playersToRender = playersToRender.filter(p => p.id !== 1);
            }
            if (gameState.layoutMode === '3v') {
                [1,2].forEach(pid => {
                    const player = playersToRender.find(p => p.id === pid);
                    if (player) {
                        const card = createPlayerCard(player);
                        card.classList.add('col-span-1', 'row-start-1');
                        card.querySelector('.content-wrapper').style.transform = 'rotate(180deg)';
                        ui.playersContainer.appendChild(card);
                    }
                });
                const player3 = playersToRender.find(p => p.id === 3);
                if (player3) {
                    const card = createPlayerCard(player3);
                    card.classList.add('col-span-2', 'row-start-2');
                    card.style.width = "100%";
                    card.style.gridColumn = "1 / span 2";
                    card.querySelector('.content-wrapper').style.transform = '';
                    ui.playersContainer.appendChild(card);
                }
            } else if (gameState.layoutMode === '3') {
                [1,2].forEach(pid => {
                    const player = playersToRender.find(p => p.id === pid);
                    if (player) {
                        const card = createPlayerCard(player);
                        card.classList.add('col-span-1', 'row-start-1');
                        card.querySelector('.content-wrapper').style.transform = 'rotate(180deg)';
                        ui.playersContainer.appendChild(card);
                    }
                });
                const player3 = playersToRender.find(p => p.id === 3);
                if (player3) {
                    const card = createPlayerCard(player3);
                    card.classList.add('col-span-2', 'row-start-2');
                    card.style.width = "100%";
                    card.style.gridColumn = "1 / span 2";
                    card.querySelector('.content-wrapper').style.transform = '';
                    ui.playersContainer.appendChild(card);
                }
            } else {
                playersToRender.forEach((player) => {
                    ui.playersContainer.appendChild(createPlayerCard(player));
                });
            }
            if (getPlayerCountFromLayout(gameState.layoutMode) === 5 && gameState.layoutMode === '5') {
                const placeholder = document.createElement('div');
                placeholder.className = 'hidden md:block md:col-start-1';
                ui.playersContainer.insertBefore(placeholder, ui.playersContainer.children[3]);
            }
            renderAllCards();
        };

        const get6BActualOpponent = (startPlayerId, initialOpponentId, activePlayerIds) => {
            let currentOpponentId = initialOpponentId;
            let path = [startPlayerId];
            while (currentOpponentId && !activePlayerIds.includes(currentOpponentId)) {
                path.push(currentOpponentId);
                const defeatedId = currentOpponentId;
                const connections = [ COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[defeatedId].left, COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[defeatedId].right ];
                currentOpponentId = connections.find(id => !path.includes(id));
                if (path.length > 7) return null;
            }
            return currentOpponentId;
        };

        const applyDamage = () => {
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (activePlayers.length < 2) return [];
            
            activePlayers.forEach(p => p.lastDamageTaken = 0);
            const damageTaken = gameState.players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
            const isBMode = ['6B', '6C', '5B', '5C', '3B'].includes(gameState.layoutMode);
            
            if (activePlayers.length === 2) {
                const [p1, p2] = activePlayers;
                damageTaken[p2.id] += Math.max(0, p1.atk - p2.block);
                damageTaken[p1.id] += Math.max(0, p2.atk - p1.block);
            } else if (isBMode && gameState.layoutMode !== '6C') {
                const activePlayerIds = activePlayers.map(p => p.id);
                activePlayers.forEach(attacker => {
                    const actualLeftOpponentId = get6BActualOpponent(attacker.id, COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[attacker.id].left, activePlayerIds);
                    const actualRightOpponentId = get6BActualOpponent(attacker.id, COMBAT_PAIRS_6B_PLAYER_PERSPECTIVE[attacker.id].right, activePlayerIds);
                    const leftTarget = gameState.players.find(p => p.id === actualLeftOpponentId);
                    const rightTarget = gameState.players.find(p => p.id === actualRightOpponentId);
                    if (leftTarget) damageTaken[leftTarget.id] += Math.max(0, attacker.atk - leftTarget.rightBlock);
                    if (rightTarget) damageTaken[rightTarget.id] += Math.max(0, attacker.atk - rightTarget.leftBlock);
                });
            } else {
                let activePlayerOrder;
                if (gameState.layoutMode === '6C') {
                    activePlayerOrder = B_MODE_TURN_ORDERS['6C'].filter(id => activePlayers.some(p => p.id === id));
                } else {
                    activePlayerOrder = CUSTOM_ORDERS[gameState.initialPlayerCount].filter(id => activePlayers.some(p => p.id === id));
                }
                activePlayerOrder.forEach((attackerId, index) => {
                    const attacker = gameState.players.find(p => p.id === attackerId);
                    const leftDefender = gameState.players.find(p => p.id === activePlayerOrder[(index + 1) % activePlayerOrder.length]);
                    const rightDefender = gameState.players.find(p => p.id === activePlayerOrder[(index - 1 + activePlayerOrder.length) % activePlayerOrder.length]);
                    if (leftDefender) damageTaken[leftDefender.id] += Math.max(0, attacker.atk - leftDefender.rightBlock);
                    if (rightDefender) damageTaken[rightDefender.id] += Math.max(0, attacker.atk - rightDefender.leftBlock);
                });
            }

            const newlyDefeatedPlayers = [];
            activePlayers.forEach(p => {
                const finalDamage = Math.max(0, damageTaken[p.id] - p.def);
                if (finalDamage > 0) {
                    p.lastDamageTaken = finalDamage;
                    p.life -= finalDamage;
                    if (p.life <= 0 && !p.isDefeated) newlyDefeatedPlayers.push(p);
                }
            });
            return newlyDefeatedPlayers;
        };
        

        // Minimal simple game over logic and popup
        function checkSimpleGameOver() {
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ú‡∏π‡πâ‡πÅ‡∏û‡πâ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
            gameState.players.forEach(p => { p.isDefeated = false; });
            // Mark all players with life < 1 as defeated ‡πÅ‡∏•‡∏∞‡∏™‡∏∏‡πà‡∏° taunt
            gameState.players.forEach(p => {
                if (p.life < 1) {
                    p.isDefeated = true;
                    // ‡∏™‡∏∏‡πà‡∏° taunt ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏û‡πâ
                    const taunts = DEFEAT_TAUNTS[gameState.currentLang] || [];
                    p.defeatTaunt = taunts.length ? taunts[Math.floor(Math.random() * taunts.length)] : '';
                } else {
                    p.defeatTaunt = null;
                }
            });
            // ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏µ‡πà active ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (previousPlayerState)
            const lastActivePlayers = Array.isArray(gameState.previousPlayerState)
                ? gameState.previousPlayerState.filter(p => !p.isDefeated).map(p => p.id)
                : gameState.players.filter(p => !p.isInitiallyDefeated).map(p => p.id);
            const survivors = gameState.players.filter(p => !p.isDefeated && lastActivePlayers.includes(p.id));
            let winner = null;
            let isDraw = false;
            if (survivors.length === 1) {
                winner = survivors[0];
            } else if (survivors.length === 0) {
                // ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô life < 1 ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà life ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡πÉ‡∏Å‡∏•‡πâ 1 ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î) ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏° lastActivePlayers
                const maxLife = Math.max(...gameState.players.filter(p => lastActivePlayers.includes(p.id)).map(p => p.life));
                const candidates = gameState.players.filter(p => lastActivePlayers.includes(p.id) && p.life === maxLife);
                if (candidates.length === 1) {
                    winner = candidates[0];
                } else {
                    isDraw = true;
                }
            }
            if (winner || isDraw) {
                showSimpleGameOver(winner, isDraw);
                return true;
            }
            return false;
        }

        function showSimpleGameOver(winner, isDraw) {
            const lang = gameState.currentLang;
            let msg = '';
            const modalBox = document.getElementById('simple-gameover-modal-box');
            if (winner) {
                // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤
                const colorName = lang === 'th' ? winner.name : winner.name_en;
                const winnerColor = `<span style="text-shadow:0 2px 8px #000,0 0 2px #fff;font-weight:bold;">${colorName}</span>`;
                msg = `<span style="font-size:2.5rem;display:block;">üèÜ</span>` +
                    `<span style="font-size:2rem;">${TRANSLATIONS[lang].gameOverTitle || 'Game Over!'}</span><br>` +
                    `<span style="font-size:1.5rem;">` +
                    (TRANSLATIONS[lang].winnerMsg ? TRANSLATIONS[lang].winnerMsg(winnerColor) : `Player ${winnerColor} wins!`) +
                    `</span><br><span style="font-size:1.1rem;opacity:0.85;">${lang==='th' ? '‡∏ä‡∏±‡∏¢‡∏ä‡∏ô‡∏∞‡∏≠‡∏±‡∏ô‡∏¢‡∏¥‡πà‡∏á‡πÉ‡∏´‡∏ç‡πà‡πÅ‡∏´‡πà‡∏á‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì!' : 'A glorious victory in this epic war!'}</span>`;
                modalBox.className = `p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full transition-all duration-300 ${winner.tailwindClass} text-white`;
            } else if (isDraw) {
                msg = `<span style="font-size:2.5rem;display:block;">‚öîÔ∏è</span>` +
                    `<span style="font-size:2rem;">${TRANSLATIONS[lang].gameOverTitle || 'Game Over!'}</span><br>` +
                    `<span style="font-size:1.5rem;">${TRANSLATIONS[lang].noWinnerMsg || 'No Winner!'}</span><br>` +
                    `<span style="font-size:1.1rem;opacity:0.85;">${lang==='th' ? '‡∏ó‡∏∏‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡πà‡∏≤‡∏á‡∏•‡πâ‡∏°‡∏•‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏®‡∏±‡∏Å‡∏î‡∏¥‡πå‡∏®‡∏£‡∏µ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏≠‡∏î‡πÉ‡∏ô‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏°‡∏ô‡∏µ‡πâ' : 'All have fallen with honor. None remain standing in this war.'}</span>`;
                modalBox.className = 'p-12 rounded-3xl shadow-2xl text-center max-w-xl w-full transition-all duration-300 bg-black text-red-600';
            }
            ui.simpleGameOverMessage.innerHTML = msg;
            ui.simpleGameOverModal.classList.remove('hidden');
            // Show only undo after game over
            ui.nextTurnContainer.classList.remove('hidden');
            ui.undoBtn.disabled = false;
            ui.nextTurnBtn.disabled = true;
            ui.nextTurnBtn.classList.add('hidden');
            gameState.isGameOver = true;
        }

        const passFirstPlayerToken = () => {
            const isBMode = B_MODE_TURN_ORDERS.hasOwnProperty(gameState.layoutMode);
            const order = isBMode ? B_MODE_TURN_ORDERS[gameState.layoutMode] : CUSTOM_ORDERS[gameState.initialPlayerCount] || [];
            
            const activePlayers = gameState.players.filter(p => !p.isDefeated);
            if (order.length === 0 || !gameState.firstPlayerId || activePlayers.length < 2) {
                gameState.firstPlayerId = activePlayers.length > 0 ? activePlayers[0]?.id : null; 
                return;
            };

            const startIndex = order.indexOf(gameState.firstPlayerId);
            if (startIndex === -1) { 
                gameState.firstPlayerId = activePlayers.find(p => order.includes(p.id))?.id || activePlayers[0]?.id;
                return; 
            }

            for (let i = 1; i <= order.length; i++) {
                const nextPlayerId = order[(startIndex + i) % order.length];
                if (activePlayers.some(p => p.id === nextPlayerId)) { 
                    gameState.firstPlayerId = nextPlayerId; 
                    return; 
                }
            }
            gameState.firstPlayerId = activePlayers[0]?.id;
        };


        
        const handleRoundEnd = () => {
            gameState.previousPlayerState = JSON.parse(JSON.stringify(gameState.players));
            const lifeBeforeDamage = gameState.players.map(p => ({ id: p.id, life: p.life, manualLifeChange: p.manualLifeChange }));

            let defeatedBeforeCombat = [];
            const playersAtRoundStart = gameState.players.filter(p => !p.isDefeated);
            playersAtRoundStart.forEach(p => {
                if (p.life <= 0) {
                    defeatedBeforeCombat.push(p);
                }
            });

            logEvent(`<strong>--- Combat Phase ---</strong>`);
            const defeatedInCombat = applyDamage();
            const allNewlyDefeated = [...new Set([...defeatedBeforeCombat, ...defeatedInCombat])];

            gameState.isBuyPhase = true;

            playersAtRoundStart.forEach(p => {
                const lifeData = lifeBeforeDamage.find(data => data.id === p.id);
                const manualChangeStr = lifeData.manualLifeChange !== 0 ? ` (${lifeData.manualLifeChange > 0 ? '+' : ''}${lifeData.manualLifeChange})` : '';
                let logStr = `- <span class="${p.textColorClass}">P${p.id}</span> | Life:${lifeData.life}${manualChangeStr} | ATK:${p.atk} DEF:${p.def}`;
                if (playersAtRoundStart.length > 2) {
                    logStr += `, L.Block:${p.leftBlock}, R.Block:${p.rightBlock}`;
                } else {
                    logStr += `, Block:${p.block}`;
                }
                if (p.lastDamageTaken > 0) {
                    logStr += ` | Took: ${p.lastDamageTaken} DMG > New Life: ${p.life}`;
                }
                logEvent(logStr);
            });

            renderAllCards();
            // Check for game over and show popup if needed
            if (!checkSimpleGameOver()) {
                ui.nextTurnContainer.classList.remove('hidden');
            }
        };

        const startNextTurn = () => {
            if (gameState.isGameOver) return;
            gameState.previousPlayerState = null;
            gameState.isBuyPhase = false;
            ui.nextTurnContainer.classList.add('hidden');
            passFirstPlayerToken();
            resetPlayerTurnStats();
            gameState.turnCount++;
            ui.turnLogIndicator.textContent = gameState.turnCount;
            logEvent(`<strong>--- ${TRANSLATIONS[gameState.currentLang].logTurn(gameState.turnCount)} ---</strong>`);
            renderAllCards();
            // Check for game over and show popup if needed (in case all die in buy phase)
            checkSimpleGameOver();
        };

        const handleUndo = () => {
            if (!gameState.previousPlayerState) return;
            gameState.players = JSON.parse(JSON.stringify(gameState.previousPlayerState));
            gameState.isBuyPhase = false;
            gameState.previousPlayerState = null;
            gameState.isGameOver = false;
            ui.nextTurnBtn.disabled = false;
            ui.nextTurnBtn.classList.remove('hidden');
            ui.nextTurnContainer.classList.add('hidden');
            // ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏≤‡∏° state ‡∏ó‡∏µ‡πà undo ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ (‡πÑ‡∏°‡πà mark isDefeated ‡πÉ‡∏´‡∏°‡πà)
            renderAllCards();
        };


        const performPlayerAction = (playerId, action) => {
            const player = gameState.players.find(p => p.id === playerId);
            if (!player || player.isDefeated) return;

            if (action === 'increment-life' || action === 'decrement-life') {
                const value = action === 'increment-life' ? 1 : -1;
                const oldLife = player.life;
                player.life += value;
                player.manualLifeChange += value;
                showLifeChangeIndicator(player.id, player.manualLifeChange);
                if(gameState.isBuyPhase) logEvent(`- <span class="${player.textColorClass}">P${player.id}</span>'s life changed: ${oldLife} -> ${player.life}.`);
                updatePlayerCard(player);
                return;
            }
            
            if (action === 'ready') {
                if (gameState.isBuyPhase) return;
                player.isReady = !player.isReady;
                updatePlayerCard(player);
                checkAllReady();
                return;
            }

            if (player.isReady || gameState.isBuyPhase) return;

            const [operation, property] = action.split('-');
            if (['atk', 'def', 'block', 'leftBlock', 'rightBlock'].includes(property)) {
                const value = operation === 'increment' ? 1 : -1;
                player[property] += value;
                player[property] = Math.max(0, player[property]);
                updatePlayerCard(player);
            }
        };

        const handlePlayerInteraction = (event) => {
            event.preventDefault();
            const touch = event.changedTouches ? event.changedTouches[0] : event;
            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
            const button = targetElement ? targetElement.closest('button[data-action]') : null;
            if (button) performPlayerAction(parseInt(button.dataset.playerId), button.dataset.action);
        };

        const showRandomNumber = () => {
            if (gameState.initialPlayerCount === 0) return;
            const maxRange = gameState.initialPlayerCount + 3;
            const randomNumber = Math.floor(Math.random() * maxRange) + 1;
            ui.randomResultBox.textContent = randomNumber;
            ui.randomResultBox.classList.remove('hidden');
            ui.randomResultBox.classList.add('show');
            setTimeout(() => {
                ui.randomResultBox.classList.remove('show');
                setTimeout(() => ui.randomResultBox.classList.add('hidden'), 500);
            }, 1500);
        };

        const updateColorPreview = () => {
            const count = getPlayerCountFromLayout(ui.playerCountSelector.value);
            const shuffledFamilies = shuffleArray(COLOR_FAMILIES);
            const selectedFamilies = shuffledFamilies.slice(0, count);
            gameState.previewColors = selectedFamilies.map(family => family[Math.floor(Math.random() * family.length)]);
            
            // Check if colorPreview element exists
            const colorPreviewElement = document.getElementById('color-preview');
            if (colorPreviewElement) {
                colorPreviewElement.innerHTML = gameState.previewColors.map(color => `<div class="w-6 h-6 rounded-full shadow-md transition-all duration-300 ${color.tailwindClass}"></div>`).join('');
            }
        };

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å burger menu
        const startDragging = (event) => {
            const touch = event.touches ? event.touches[0] : event;
            const rect = ui.menuContainer.getBoundingClientRect();
            
            gameState.isDragging = true;
            gameState.hasMoved = false;
            gameState.dragOffset.x = touch.clientX - rect.left;
            gameState.dragOffset.y = touch.clientY - rect.top;
            gameState.startX = touch.clientX;
            gameState.startY = touch.clientY;
            
            ui.menuContainer.classList.add('dragging');
        };

        const drag = (event) => {
            if (!gameState.isDragging) return;
            
            const touch = event.touches ? event.touches[0] : event;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            const threshold = 10; // pixel threshold
            const deltaX = Math.abs(touch.clientX - gameState.startX);
            const deltaY = Math.abs(touch.clientY - gameState.startY);
            
            if (deltaX > threshold || deltaY > threshold) {
                gameState.hasMoved = true;
                event.preventDefault(); // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô scroll ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏•‡∏≤‡∏Å
            }
            
            // ‡∏•‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            if (gameState.hasMoved) {
                const x = touch.clientX - gameState.dragOffset.x;
                const y = touch.clientY - gameState.dragOffset.y;
                
                // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
                const maxX = window.innerWidth - ui.menuContainer.offsetWidth;
                const maxY = window.innerHeight - ui.menuContainer.offsetHeight;
                
                const clampedX = Math.max(0, Math.min(x, maxX));
                const clampedY = Math.max(0, Math.min(y, maxY));
                
                ui.menuContainer.style.left = clampedX + 'px';
                ui.menuContainer.style.top = clampedY + 'px';
                ui.menuContainer.style.right = 'auto';
                ui.menuContainer.style.transform = 'none';
            }
        };

        const stopDragging = () => {
            if (!gameState.isDragging) return;
            
            gameState.isDragging = false;
            ui.menuContainer.classList.remove('dragging');
            
            // ‡∏õ‡∏£‡∏±‡∏ö dropdown position ‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á menu (4 ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å)
            const rect = ui.menuContainer.getBoundingClientRect();
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // ‡∏•‡∏ö class ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô
            ui.menuContainer.classList.remove('position-left', 'position-right', 'position-top', 'position-bottom');
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á 4 ‡∏î‡πâ‡∏≤‡∏ô
            const distanceTop = rect.top;
            const distanceBottom = window.innerHeight - rect.bottom;
            const distanceLeft = rect.left;
            const distanceRight = window.innerWidth - rect.right;
            
            // ‡∏´‡∏≤‡∏Ç‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á dropdown ‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
            const minDistance = Math.min(distanceTop, distanceBottom, distanceLeft, distanceRight);
            
            if (minDistance === distanceTop) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏ö‡∏ô -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
                ui.menuContainer.classList.add('position-bottom');
            } else if (minDistance === distanceBottom) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô  
                ui.menuContainer.classList.add('position-top');
            } else if (minDistance === distanceLeft) {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏ã‡πâ‡∏≤‡∏¢ -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤
                ui.menuContainer.classList.add('position-right');
            } else {
                // ‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏ß‡∏≤ -> dropdown ‡πÅ‡∏™‡∏î‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢ (default)
                // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° class ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏õ‡πá‡∏ô default style
            }
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï hasMoved ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å delay ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö touch events)
            setTimeout(() => {
                gameState.hasMoved = false;
            }, 100);
        };
        
        const handleFullscreenChange = () => {
            if (document.fullscreenElement) {
                manageWakeLock(true);
            } else {
                manageWakeLock(false);
            }
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô fullscreen state
            setTimeout(() => recalculateAllCards(), 500);
        };
        
        const handleVisibilityChange = () => {
            if (document.visibilityState === 'visible' && document.fullscreenElement) {
                manageWakeLock(true);
            }
        };

        const setupEventListeners = () => {
                ui.startBtn.addEventListener('click', startGame);
                if (ui.iphoneSafeAreaToggle) {
                    ui.iphoneSafeAreaToggle.addEventListener('change', updateSafeAreaPadding);
                }
            ui.startBtn.addEventListener('click', startGame);
            
            // Event listeners ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å burger menu
            ui.menuBtn.addEventListener('mousedown', startDragging);
            ui.menuBtn.addEventListener('touchstart', startDragging, { passive: true });
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            
            document.addEventListener('mouseup', stopDragging);
            document.addEventListener('touchend', stopDragging);
            // Removed modalResetBtn and gameOverModal event listeners (no longer in DOM)
            ui.turnLogIndicator.addEventListener('click', () => { updateLogModal(); ui.logModal.classList.remove('hidden'); });
            ui.closeLogBtn.addEventListener('click', () => ui.logModal.classList.add('hidden'));
            ui.playersContainer.addEventListener('touchstart', handlePlayerInteraction, { passive: false });
            ui.playersContainer.addEventListener('click', handlePlayerInteraction);
            // Handle click/tap for opening menu
            const handleMenuClick = (event) => {
                // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î menu ‡∏´‡∏≤‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏•‡∏≤‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à
                if (!gameState.hasMoved && !gameState.isDragging) {
                    ui.menuDropdown.classList.toggle('active');
                }
            };
            
            ui.menuBtn.addEventListener('click', handleMenuClick);
            ui.menuBtn.addEventListener('touchend', (event) => {
                if (!gameState.hasMoved && !gameState.isDragging) {
                    event.preventDefault();
                    handleMenuClick(event);
                }
            });
            ui.restartGameBtn.addEventListener('click', () => ui.confirmModal.classList.remove('hidden'));
            ui.randomBtn.addEventListener('click', showRandomNumber);
            ui.nextTurnBtn.addEventListener('click', startNextTurn);
            ui.undoBtn.addEventListener('click', handleUndo);
            ui.toggleFullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // 3v mode ‡∏ï‡πâ‡∏≠‡∏á‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô portrait-primary ‡πÄ‡∏™‡∏°‡∏≠
                    let o = 'landscape';
                    if (gameState.layoutMode === '3v' || gameState.initialPlayerCount === 2 || ['6B', '6C', '5B', '5C', '3B'].includes(gameState.layoutMode)) {
                        o = 'portrait-primary';
                    }
                    goFullscreen(o);
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô fullscreen
                setTimeout(() => recalculateAllCards(), 300);
            });
            ui.languageSelector.addEventListener('change', (event) => setLanguage(event.target.value));
            ui.playerCountSelector.addEventListener('change', () => {
                updateColorSelectOnPlayerCountChange();
            });
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('visibilitychange', handleVisibilityChange);

            ui.confirmCancelBtn.addEventListener('click', () => ui.confirmModal.classList.add('hidden'));
            ui.confirmOkBtn.addEventListener('click', () => {
                ui.confirmModal.classList.add('hidden');
                setTimeout(resetGame, 50);
            });

            const closeMenuHandler = (event) => {
                if (ui.menuDropdown.classList.contains('active') && !ui.menuContainer.contains(event.target)) {
                    ui.menuDropdown.classList.remove('active');
                }
            };
            document.addEventListener('click', closeMenuHandler);
            document.addEventListener('touchstart', closeMenuHandler);

            ui.menuDropdown.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    ui.menuDropdown.classList.remove('active');
                }
            });
        };
        
        document.addEventListener('DOMContentLoaded', () => {
              updateSafeAreaPadding();
            setLanguage(gameState.currentLang);
            renderColorSelectPanel();
            setupEventListeners();
            // Simple game over modal close button
            ui.simpleGameOverClose.addEventListener('click', () => {
                ui.simpleGameOverModal.classList.add('hidden');
                resetGame();
            });
            // Allow closing modal by clicking outside the box
            ui.simpleGameOverModal.addEventListener('click', (e) => {
                if (e.target === ui.simpleGameOverModal) {
                    ui.simpleGameOverModal.classList.add('hidden');
                }
            });
        });
    </script>
</body>
</html>

